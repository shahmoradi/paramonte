<!-- HTML header for doxygen 1.9.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="$langISO">
<head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=11"/>
    <meta name="generator" content="Doxygen 1.9.3"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>ParaMonte Fortran 2.0.0: pm_polynomial Module Reference</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
   TeX: { Macros: {
    up: ["{{\\mathrm{#1}}}",1],
    bs: ["{{\\boldsymbol{#1}}}",1],
    ms: ["{\\texttt{#1}}",1],
    diff: "{{\\mathrm{d}}}",
    bu: ["{{\\boldsymbol{\\mathrm{#1}}}}",1],
    sline: "{\\rule{\\textwidth}{1pt}}",
    sphere: "{{\\mathcal{S}}}",
    ell: "{{\\mathcal{E}}}",
    ndim: "{{\\ms{ndim}}}",
    gramian: "{{\\mathcal{G}}}",
    mat: ["{{\\boldsymbol{\\mathrm {#1}}}}",1],
    unit: ["{{\\boldsymbol{\\widehat{\\mathrm{#1}}}}}",1],
    ebreak: "{{E_\\ms{b}}}",
    xbreak: "{{x_\\ms{b}}}",
    efold: "{{E_\\ms{f}}}",
    epeak: "{{E_\\ms{p}}}",
    phot: "{{\\ms{ph}}}",
    ergs: "{{\\ms{ergs}}}",
    sergs: "{{S_{\\ms{ergs}}}}",
    sphot: "{{S_{\\phot}}}",
    kev: "{{\\ms{keV}}}",
    det: "{{\\ms{det}}}",
    var: "{{\\ms{var}}}",
  } }
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="html_extra_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
        <div id="titlearea">
            <table cellspacing="0" cellpadding="0" stype="z-index:-1;">
                <tbody>
                    <tr id="projectrow">
                        <td id="projectlogo">
                            <a href="https://www.cdslab.org/paramonte/" target="_blank"><img alt="Logo" src="logo.png"/></a>
                        </td>
                        <td id="projectalign">
                            <div id="projectname">
                                ParaMonte Fortran 2.0.0
                            </div>
                            <div id="projectbrief">
                                Parallel Monte Carlo and Machine Learning Library<br><a href="../latest/index.html" target="_blank">See the latest version documentation.</a>
                            </div>
                        </td>
                        <!--
                        <td id="projectalign" style="padding-left: 0.5em;">
                            <a href="https://github.com/cdslaborg/paramonte/releases" target="_blank">
                                <div id="projectname">
                                    <span id="projectbrief">Parallel Monte Carlo &#38;</span>
                                    <span id="projectbrief">Machine Learning Library</span>
                                    <span id="projectbrief">Version </span>
                                </div>
                            </a>
                        </td>
                        <td style="padding-left: 0.5em;">
                            <div id="projectbrief">Parallel Monte Carlo and Machine Learning Library</div>
                        </td>
                        -->
                    </tr>
                </tbody>
            </table>
        </div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacepm__polynomial.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Types</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">pm_polynomial Module Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This module contains procedures and generic interfaces for performing various mathematical operations involving polynomials.<br  />
  
<a href="namespacepm__polynomial.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Types</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpm__polynomial_1_1eigen__type.html">eigen_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a concrete derived type whose instances are exclusively used to signify the use of the Eigenvalue method of root-finding.<br  />
  <a href="structpm__polynomial_1_1eigen__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacepm__polynomial_1_1getPolyAdd.html">getPolyAdd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate and return the vector of coefficients of the polynomial resulting from the addition of a polynomial to another polynomial of arbitrary degrees.  <a href="interfacepm__polynomial_1_1getPolyAdd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacepm__polynomial_1_1getPolyDiff.html">getPolyDiff</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate and return the vector of coefficients of the polynomial resulting from the \(k\)th-order differentiation of a univariate polynomial of arbitrary degree.  <a href="interfacepm__polynomial_1_1getPolyDiff.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacepm__polynomial_1_1getPolyMul.html">getPolyMul</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate and return the vector of coefficients of the polynomial resulting from the multiplication of a polynomial with another polynomial of arbitrary degrees.  <a href="interfacepm__polynomial_1_1getPolyMul.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacepm__polynomial_1_1getPolyRoot.html">getPolyRoot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate and return the roots of a polynomial of arbitrary degree specified by its coefficients <code>coef</code>.<br  />
  <a href="interfacepm__polynomial_1_1getPolyRoot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacepm__polynomial_1_1getPolyStr.html">getPolyStr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate and return a string containing the polynomial expression corresponding to the input polynomial coefficients.  <a href="interfacepm__polynomial_1_1getPolyStr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacepm__polynomial_1_1getPolySub.html">getPolySub</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate and return the vector of coefficients of the polynomial resulting from the subtraction of a polynomial to another polynomial of arbitrary degrees.  <a href="interfacepm__polynomial_1_1getPolySub.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacepm__polynomial_1_1getPolyVal.html">getPolyVal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate and return the value of the polynomial of arbitrary degree whose coefficients are specified by the user in the order of increasing power.<br  />
  <a href="interfacepm__polynomial_1_1getPolyVal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpm__polynomial_1_1jenkins__type.html">jenkins_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a concrete derived type whose instances are exclusively used to signify the use of <b>Jenkins-Traub</b> method of root-finding.<br  />
  <a href="structpm__polynomial_1_1jenkins__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpm__polynomial_1_1laguerre__type.html">laguerre_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a concrete derived type whose instances are exclusively used to signify the use of <b>Laguerre</b> method of root-finding.<br  />
  <a href="structpm__polynomial_1_1laguerre__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpm__polynomial_1_1method__type.html">method_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an <code>abstract</code> derived type for constructing concrete derived types to distinguish various procedure signatures that require root-finding methods (e.g., Eigenvalue, Jenkins, Laguerre, ...).<br  />
  <a href="structpm__polynomial_1_1method__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacepm__polynomial_1_1setPolyAdd.html">setPolyAdd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the vector of coefficients of the polynomial resulting from the addition of a polynomial to another polynomial of arbitrary degrees.  <a href="interfacepm__polynomial_1_1setPolyAdd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacepm__polynomial_1_1setPolyDiff.html">setPolyDiff</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the vector of coefficients of the polynomial resulting from the \(k\)th-order differentiation of a univariate polynomial of arbitrary degree.  <a href="interfacepm__polynomial_1_1setPolyDiff.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacepm__polynomial_1_1setPolyDiv.html">setPolyDiv</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the quotient and remainder of dividing a polynomial with another polynomial of arbitrary degrees.  <a href="interfacepm__polynomial_1_1setPolyDiv.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacepm__polynomial_1_1setPolyMul.html">setPolyMul</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the vector of coefficients of the polynomial resulting from the multiplication of a polynomial with another polynomial of arbitrary degrees.  <a href="interfacepm__polynomial_1_1setPolyMul.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacepm__polynomial_1_1setPolyRoot.html">setPolyRoot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the roots of a polynomial of arbitrary degree specified by its coefficients <code>coef</code>.<br  />
  <a href="interfacepm__polynomial_1_1setPolyRoot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacepm__polynomial_1_1setPolyRootPolished.html">setPolyRootPolished</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the polished (refined) root of a polynomial of arbitrary degree specified by its coefficients <code>coef</code>.<br  />
  <a href="interfacepm__polynomial_1_1setPolyRootPolished.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacepm__polynomial_1_1setPolySub.html">setPolySub</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the vector of coefficients of the polynomial resulting from the subtraction of a polynomial to another polynomial of arbitrary degrees.  <a href="interfacepm__polynomial_1_1setPolySub.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a7ed954ba0101852d40ea302341567ac1"><td class="memItemLeft" align="right" valign="top">character(*, SK), parameter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepm__polynomial.html#a7ed954ba0101852d40ea302341567ac1">MODULE_NAME</a> = &quot;@pm_polynomial&quot;</td></tr>
<tr class="separator:a7ed954ba0101852d40ea302341567ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf1d29725012070ab27ec81918df46b"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structpm__polynomial_1_1eigen__type.html">eigen_type</a>), parameter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepm__polynomial.html#a4bf1d29725012070ab27ec81918df46b">eigen</a> = <a class="el" href="structpm__polynomial_1_1eigen__type.html">eigen_type</a>()</td></tr>
<tr class="memdesc:a4bf1d29725012070ab27ec81918df46b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a scalar <code>parameter</code> object of type <a class="el" href="structpm__polynomial_1_1eigen__type.html">eigen_type</a> that is exclusively used to signify the use of Eigenvalue method of root-finding within an interface of a procedure of the ParaMonte library.<br  />
  <a href="namespacepm__polynomial.html#a4bf1d29725012070ab27ec81918df46b">More...</a><br /></td></tr>
<tr class="separator:a4bf1d29725012070ab27ec81918df46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f657eba9f64f4e251a5f1b67f0ba02"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structpm__polynomial_1_1jenkins__type.html">jenkins_type</a>), parameter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepm__polynomial.html#ac1f657eba9f64f4e251a5f1b67f0ba02">jenkins</a> = <a class="el" href="structpm__polynomial_1_1jenkins__type.html">jenkins_type</a>()</td></tr>
<tr class="memdesc:ac1f657eba9f64f4e251a5f1b67f0ba02"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a scalar <code>parameter</code> object of type <a class="el" href="structpm__polynomial_1_1jenkins__type.html">jenkins_type</a> that is exclusively used to signify the use of <b>Jenkins-Traub</b> method of root-finding within an interface of a procedure of the ParaMonte library.<br  />
  <a href="namespacepm__polynomial.html#ac1f657eba9f64f4e251a5f1b67f0ba02">More...</a><br /></td></tr>
<tr class="separator:ac1f657eba9f64f4e251a5f1b67f0ba02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a9b1776fa3670d5b3cb401d91026e3"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structpm__polynomial_1_1laguerre__type.html">laguerre_type</a>), parameter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepm__polynomial.html#ad7a9b1776fa3670d5b3cb401d91026e3">laguerre</a> = <a class="el" href="structpm__polynomial_1_1laguerre__type.html">laguerre_type</a>()</td></tr>
<tr class="memdesc:ad7a9b1776fa3670d5b3cb401d91026e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a scalar <code>parameter</code> object of type <a class="el" href="structpm__polynomial_1_1laguerre__type.html">laguerre_type</a> that is exclusively used to signify the use of <b>Laguerre</b> method of root-finding within an interface of a procedure of the ParaMonte library.<br  />
  <a href="namespacepm__polynomial.html#ad7a9b1776fa3670d5b3cb401d91026e3">More...</a><br /></td></tr>
<tr class="separator:ad7a9b1776fa3670d5b3cb401d91026e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >This module contains procedures and generic interfaces for performing various mathematical operations involving polynomials.<br  />
 </p>
<p >Specifically, this module contains generic interfaces for the following computational polynomial tasks:<br  />
 </p><ol>
<li>
Evaluation of <a class="el" href="interfacepm__polynomial_1_1getPolyVal.html">polynomial functions</a> using the Horner method.<br  />
 </li>
<li>
Evaluation of the <a class="el" href="interfacepm__polynomial_1_1getPolyRoot.html">roots of polynomials</a> of arbitrary degrees.<br  />
 </li>
<li>
Evaluation of the <a class="el" href="interfacepm__polynomial_1_1getPolyAdd.html">addition of two polynomials</a> of arbitrary degrees.<br  />
 </li>
<li>
Evaluation of the <a class="el" href="interfacepm__polynomial_1_1getPolySub.html">subtraction of two polynomials</a> of arbitrary degrees.<br  />
 </li>
<li>
Evaluation of the <a class="el" href="interfacepm__polynomial_1_1getPolyDiff.html">differentiation of polynomials</a> of arbitrary degrees.<br  />
 </li>
<li>
converting univariate polynomial coefficients to <a class="el" href="interfacepm__polynomial_1_1getPolyStr.html">readable univariate polynomial expressions in string format</a> for better display.<br  />
 </li>
</ol>
<h2><a class="anchor" id="autotoc_md88"></a>
Introduction</h2>
<p >In mathematics, a polynomial is an expression consisting of <b>indeterminates</b> (also called <b>variables</b>) and <b>coefficients</b>, that involves only the operations of <b>addition</b>, <b>subtraction</b>, <b>multiplication</b>, and <b>positive-integer powers</b> of variables.<br  />
 An example of a polynomial of a single indeterminate \(x\) is \(x^2 − 4x + 7\).<br  />
 An example with three indeterminates is \(x^3 + 2xyz2 − yz + 1\).<br  />
 Polynomials appear in many areas of mathematics and science.<br  />
 For example, they are used to form polynomial equations, which encode a wide range of problems.<br  />
 They are used to define polynomial functions, which appear in settings ranging from basic chemistry and physics to economics and social science.<br  />
 They are used in calculus and numerical analysis to approximate other functions.<br  />
 In advanced mathematics, polynomials are used to construct polynomial rings and algebraic varieties, which are central concepts in algebra and algebraic geometry.<br  />
</p>
<h2><a class="anchor" id="autotoc_md89"></a>
Definition</h2>
<p >A polynomial expression is an expression that can be built from constants and symbols called variables or indeterminates by means of addition, multiplication and exponentiation to a non-negative integer power.<br  />
 The constants are generally numbers, but may be any expression that do not involve the indeterminates, and represent mathematical objects that can be added and multiplied.<br  />
 Two polynomial expressions are considered as defining the same polynomial if they may be transformed, one to the other, by applying the usual properties of commutativity, associativity and distributivity of addition and multiplication.<br  />
 For example \((x-1)(x-2)\) and \(x^{2}-3x+2\) are two polynomial expressions that represent the same polynomial.<br  />
 Therefore, one has the equality \((x-1)(x-2) = x^{2}-3x+2\).<br  />
 A polynomial in a single indeterminate x can always be written (or rewritten) in the form  </p><p class="formulaDsp">
\begin{equation}
      a_{n}x^{n}+a_{n-1}x^{n-1}+\dotsb +a_{2}x^{2}+a_{1}x+a_{0} ~,
  \end{equation}
</p>
<p> where \(a_{0}, \ldots , a_{n}\) are constants that are called the coefficients of the polynomial, and \(x\) is the indeterminate.<br  />
 The word <b>indeterminate</b> means that \(x\) represents no particular value, although any value may be substituted for it.<br  />
 The mapping that associates the result of this substitution to the substituted value is a function, called a <b>polynomial function</b>.<br  />
 This can be expressed more concisely by using summation notation:<br  />
  </p><p class="formulaDsp">
\begin{equation}
      \sum_{k = 0}^{n} a_{k}x^{k} ~.
  \end{equation}
</p>
<p >In other words, a polynomial can either be zero or can be written as the sum of a finite number of non-zero terms.<br  />
 Each term consists of the product of a number - called the coefficient of the term – and a finite number of indeterminates, raised to non-negative integer powers.<br  />
</p>
<h2><a class="anchor" id="autotoc_md90"></a>
Addition</h2>
<p >Polynomials can be added using the associative law of addition (grouping all their terms together into a single sum), possibly followed by reordering (using the commutative law) and combining of like terms.<br  />
 For example, if \(P = 3x^{2} - 2x + 5xy - 2\) and \(Q = -3x^{2} + 3x + 4y^{2} + 8\), then the sum,  </p><p class="formulaDsp">
\begin{equation}
      P + Q = 3x^{2} - 2x + 5xy - 2 - 3x^{2} + 3x + 4y^{2} + 8 ~,
  \end{equation}
</p>
<p> can be reordered and regrouped as,  </p><p class="formulaDsp">
\begin{equation}
      P + Q = (3x^{2} - 3x^{2}) + (-2x + 3x) + 5xy + 4y^{2} + (8 - 2) ~,
  \end{equation}
</p>
<p> and then simplified to,  </p><p class="formulaDsp">
\begin{equation}
      P + Q = x + 5xy + 4y^{2} + 6 ~.
  \end{equation}
</p>
<p >When polynomials are added together, the result is another polynomial.<br  />
 In summary, to add two polynomials, simply add the corresponding coefficients of terms of equal exponent in the two polynomials.<br  />
 This results in a new set of polynomial coefficients which represent the polynomial resulting from the sum of the two polynomials.<br  />
</p>
<dl class="section note"><dt>Note</dt><dd>The degree of the resulting polynomial from the addition of two other polynomials is always the maximum of the degrees of the two polynomials added.<br  />
</dd></dl>
<h2><a class="anchor" id="autotoc_md91"></a>
Subtraction</h2>
<p >Subtraction of polynomials is similar to their additions.<br  />
 To subtract two polynomials, simply subtract the corresponding coefficients of terms of equal exponent in the two polynomials.<br  />
 This results in a new set of polynomial coefficients which represent the polynomial resulting from the subtraction of the two polynomials.<br  />
</p>
<dl class="section note"><dt>Note</dt><dd>The degree of the resulting polynomial from the subtraction of two other polynomials is always the maximum of the degrees of the two polynomials subtracted.<br  />
</dd></dl>
<h2><a class="anchor" id="autotoc_md92"></a>
Multiplication</h2>
<p >Polynomials can also be multiplied.<br  />
 To expand the product of two polynomials into a sum of terms, the distributive law is repeatedly applied, which results in each term of one polynomial being multiplied by every term of the other.<br  />
 For example, if  </p><p class="formulaDsp">
\begin{equation}
      \begin{aligned}
      \color{Red}     P &amp; \color{Red}     {= 2x + 3y + 5} \\
      \color{Blue}    Q &amp; \color{Blue}    {= 2x + 5y + xy + 1}
  \end{aligned}
  \end{equation}
</p>
<p> then,  </p><p class="formulaDsp">
\begin{equation}
      \begin{array}{rccrcrcrcr}
          {\color {Red}{P}}{\color {Blue}{Q}}&amp;{=}&amp;&amp;({\color {Red}{2x}}\cdot {\color {Blue}{2x}})&amp; + &amp;({\color {Red}{2x}}\cdot {\color {Blue}{5y}})&amp; + &amp;({\color {Red}{2x}}\cdot {\color {Blue}{xy}})&amp; + &amp;({\color {Red}{2x}}\cdot {\color {Blue}{1}}) \\
          &amp;&amp; + &amp;({\color {Red}{3y}}\cdot {\color {Blue}{2x}})&amp;+&amp;({\color {Red}{3y}}\cdot {\color {Blue}{5y}})&amp;+&amp;({\color {Red}{3y}}\cdot {\color {Blue}{xy}})&amp;+&amp;({\color {Red}{3y}}\cdot {\color {Blue}{1}}) \\
          &amp;&amp; + &amp;({\color {Red}{5}}\cdot {\color {Blue}{2x}})&amp;+&amp;({\color {Red}{5}}\cdot {\color {Blue}{5y}})&amp;+&amp;({\color {Red}{5}}\cdot {\color {Blue}{xy}})&amp;+&amp;({\color {Red}{5}}\cdot {\color {Blue}{1}})
      \end{array}
  \end{equation}
</p>
<p >Carrying out the multiplication in each term produces,  </p><p class="formulaDsp">
\begin{equation}
      \begin{array}{rccrcrcrcr}
          PQ &amp;=&amp;&amp; 4x^{2}&amp;+&amp;10xy&amp;+&amp;2x^{2}y&amp;+&amp;2x \\
          &amp;&amp;+&amp;6xy&amp;+&amp;15y^{2}&amp;+&amp;3xy^{2}&amp;+&amp;3y\\
          &amp;&amp;+&amp;10x&amp;+&amp;25y&amp;+&amp;5xy&amp;+&amp;5.
      \end{array}
  \end{equation}
</p>
<p >Combining similar terms yields,  </p><p class="formulaDsp">
\begin{equation}
      \begin{array}{rcccrcrcrcr}
          PQ &amp;=&amp;&amp; 4x^{2}&amp;+&amp;(10xy+6xy+5xy)&amp;+&amp;2x^{2}y&amp;+&amp;(2x+10x) \\
          &amp;&amp;+&amp;15y^{2}&amp;+&amp;3xy^{2}&amp;+&amp;(3y+25y)&amp;+&amp;5
      \end{array}
  \end{equation}
</p>
<p> which can be simplified to,  </p><p class="formulaDsp">
\begin{equation}
  PQ = 4x^{2}+21xy+2x^{2}y+12x+15y^{2}+3xy^{2}+28y+5 ~.
  \end{equation}
</p>
<p >As in the example, <b>the product of polynomials is always a polynomial</b>.<br  />
</p>
<p >In summary, To expand the product of two polynomials into a sum of terms, the distributive law is repeatedly applied.<br  />
 This results in each term of one polynomial being multiplied by every term of the other.<br  />
</p>
<dl class="section note"><dt>Note</dt><dd>The degree of the resulting polynomial from the multiplication of two other polynomials is always the sum of the degrees of the two multiplicands plus one.<br  />
</dd></dl>
<h2><a class="anchor" id="autotoc_md93"></a>
Division</h2>
<p >The division of one polynomial by another <b>is not</b> typically a polynomial.<br  />
 Instead, such ratios are a more general family of objects, called rational fractions, rational expressions, or rational functions, depending on context.<br  />
 This is analogous to the fact that the ratio of two integers is a rational number, not necessarily an integer.<br  />
 For example, the fraction \(1 / (x^2 + 1)\) is not a polynomial, and it cannot be written as a finite sum of powers of the variable \(x\).<br  />
 For polynomials in one variable, there is a notion of <b>Euclidean division of polynomials</b>, generalizing the <b>Euclidean division of integers</b>.<br  />
 This notion of the division \(a(x) / b(x)\) results in two polynomials, a <b>quotient</b> \(q(x)\) and a <b>remainder</b> \(r(x)\), such that \(a = b q + r\) and \(\ms{degree}(r) &lt; \ms{degree}(b)\).<br  />
 The quotient and remainder may be computed by any of several algorithms, including <b>polynomial long division</b> and <b>synthetic division</b>.<br  />
 When the denominator \(b(x)\) is monic and linear, that is, \(b(x) = x − c\) for some constant \(c\), then the polynomial remainder theorem asserts that the remainder of the division of \(a(x)\) by \(b(x)\) is the evaluation \(a(c)\).<br  />
 In this case, the quotient may be computed by the Ruffini rule, a special case of synthetic division.<br  />
</p>
<h2><a class="anchor" id="autotoc_md94"></a>
Division algorithm</h2>
<p >The methodology employed in this module relies on <b>polynomial long division</b>.<br  />
 Polynomial long division is an algorithm for dividing a polynomial by another polynomial of the same or lower degree.<br  />
 It is a generalized version of the familiar arithmetic technique called <b>long division</b>.<br  />
 Another abbreviated method is <b>polynomial short division</b> (<b>Blomqvist method</b>).<br  />
 The method of polynomial long division implements the Euclidean division of polynomials.<br  />
 Starting from the polynomial \(\ms{dividend}\) and a non-zero polynomial \(\ms{divisor}\), it outputs a \(\ms{Quotient}\) polynomial and a \(\ms{Remainder}\) polynomial such that,  </p><p class="formulaDsp">
\begin{equation}
      \ms{dividend} = \ms{divisor} \times \ms{Quotient} + \ms{Remainder} ~.
  \end{equation}
</p>
<p> By definition, the resulting degree of \(\ms{Remainder}\) is lower than the degree of \(\ms{divisor}\).<br  />
 The resulting polynomials \(\ms{Quotient}\) and \(\ms{Remainder}\) are unique and do not depend on the derivation methodology.<br  />
 The result \(\ms{Remainder} = 0\) occurs <b>if and only if</b> the polynomial \(\ms{dividend}\) has \(\ms{divisor}\) as a factor.<br  />
</p>
<dl class="section note"><dt>Note</dt><dd>The polynomial division is a means for testing whether one polynomial has another as a factor, and, if it does, for factoring it out.<br  />
 For example, if \(r\) is a root of the polynomial \(\ms{dividend}\) is known, it can be factored out by dividing \(\ms{dividend}\) by \(\ms{divisor} = (x – r)\).<br  />
</dd></dl>
<p><a href="https://en.wikipedia.org/wiki/Polynomial_long_division">Polynomial long division</a><br  />
</p>
<h2><a class="anchor" id="autotoc_md95"></a>
Derivative</h2>
<p >Calculating derivatives and integrals of polynomials is particularly simple, compared to other kinds of functions.<br  />
 The derivative of the polynomial,  </p><p class="formulaDsp">
\begin{equation}
      P = a_{n}x^{n}+a_{n-1}x^{n-1}+\dots +a_{2}x^{2}+a_{1}x+a_{0}=\sum _{i=0}^{n}a_{i}x^{i} ~,
  \end{equation}
</p>
<p> with respect to \(x\) is the polynomial,  </p><p class="formulaDsp">
\begin{equation}
      na_{n}x^{n-1}+(n-1)a_{n-1}x^{n-2}+\dots +2a_{2}x+a_{1}=\sum _{i=1}^{n}ia_{i}x^{i-1} ~.
  \end{equation}
</p>
<p >Succinctly, given a polynomial of degree \(\ms{degree}\),<br  />
  </p><p class="formulaDsp">
\begin{equation}
      P(x) = \sum_{i ~=~ 0}^{i ~=~ \ms{degree}} ~ c_i x^i ~,
  \end{equation}
</p>
<p> where \(c_i\) is the \(i\)th coefficient of the polynomial, the \(k\)th-order derivative of the polynomial can be computed as,  </p><p class="formulaDsp">
\begin{equation}
      \frac{\mathrm{d}^k P(x)}{\mathrm{d}x^k} =
      \begin{cases}
          \sum_{i ~=~ k}^{i ~=~ \ms{degree}} ~ \big( \prod_{j = i - k + 1}^{j = i} \big) c_i x^{(i - k)} ~,~&amp; k &lt; \ms{degree} \\
          0  ~,~&amp; k \geq \ms{degree}
      \end{cases}
  \end{equation}
</p>
<dl class="section note"><dt>Note</dt><dd>The degree of the resulting polynomial from the \(k\)th-order differentiation of a polynomial of degree \(\ms{degree}\) is by definition \(\max(0, \ms{degree} - k)\).<br  />
</dd></dl>
<h2><a class="anchor" id="autotoc_md96"></a>
Integral</h2>
<p >Similarly, the general <b>antiderivative</b> (or <b>indefinite integral</b>) of \(P\) is,  </p><p class="formulaDsp">
\begin{equation}
      {\frac {a_{n}x^{n+1}}{n+1}}+{\frac {a_{n-1}x^{n}}{n}}+\dots +{\frac {a_{2}x^{3}}{3}}+{\frac {a_{1}x^{2}}{2}}+a_{0}x+c=c+\sum _{i=0}^{n}{\frac {a_{i}x^{i+1}}{i+1}} ~,
  \end{equation}
</p>
<p> where \(c\) is an arbitrary constant.<br  />
 For example, antiderivatives of \(x^2 + 1\) have the form \(\frac{1}{3}x^3 + x + c\).<br  />
</p>
<h2><a class="anchor" id="autotoc_md97"></a>
Polynomial functions and root-finding</h2>
<p >A polynomial equation, also called an algebraic equation, is an equation of the form,  </p><p class="formulaDsp">
\begin{equation}
      a_{n}x^{n}+a_{n-1}x^{n-1}+\dotsb +a_{2}x^{2}+a_{1}x+a_{0}=0 ~.
  \end{equation}
</p>
<p >For example,<br  />
  </p><p class="formulaDsp">
\begin{equation}
      3x^{2}+4x-5 = 0 ~,
  \end{equation}
</p>
<p> is a polynomial equation.<br  />
</p>
<p >A <b>root</b> of a nonzero univariate polynomial \(P\) is a value a of \(x\) such that \(P(a) = 0\).<br  />
 In other words, a root of \(P\) is a solution of the polynomial equation \(P(x) = 0\) or a zero of the polynomial function defined by \(P\).<br  />
 In the case of the zero polynomial, every number is a zero of the corresponding function, and the concept of root is rarely considered.<br  />
 A number \(a\) is a root of a polynomial \(P\) if and only if the linear polynomial \(x − a\) divides \(P\), that is if there is another polynomial \(Q\) such that \(P = (x − a) Q\).<br  />
 It may happen that a power (greater than 1) of \(x − a\) divides \(P\); in this case, \(a\) is a <b>multiple root</b> of \(P\), and otherwise \(a\) is a <b>simple root</b> of \(P\).<br  />
 If \(P\) is a nonzero polynomial, there is a highest power \(m\) such that \((x − a)m\) divides \(P\), which is called the multiplicity of \(a\) as a root of \(P\).<br  />
 The number of roots of a nonzero polynomial \(P\), counted with their respective <b>multiplicities</b>, cannot exceed the degree of \(P\), and equals this degree if all complex roots are considered (this is a consequence of the fundamental theorem of algebra).<br  />
 The coefficients of a polynomial and its roots are related by the Vieta formulas.<br  />
</p>
<p >Some polynomials, such as \(x^2 + 1\), do not have any roots among the real numbers.<br  />
 If, however, the set of accepted solutions is expanded to the complex numbers, every non-constant polynomial has at least one root;<br  />
 This is the fundamental theorem of algebra.<br  />
 By successively dividing out factors \(x − a\), one sees that any polynomial with complex coefficients can be written as a constant (its leading coefficient) times a product of such polynomial factors of degree \(1\);<br  />
 Consequently, <b>the number of (complex) roots counted with their multiplicities is exactly equal to the degree of a polynomial</b>.<br  />
</p>
<h2><a class="anchor" id="autotoc_md98"></a>
Polynomial root-finding: Eigenvalue method</h2>
<p >Given the <code>real</code> or <code>complex</code> coefficients \(c_i\) of a polynomial of degree \(n &gt; 0\),<br  />
  </p><p class="formulaDsp">
\begin{equation}
      f(x) = \sum_{i = 0}^{n} ~ c_i x^{i} ~,
  \end{equation}
</p>
<p> the procedures of this module compute the \(n\) (potentially <code>complex</code>) roots of the polynomial \(f(x)\).<br  />
 The roots are always returned as <code>complex</code> numbers as polynomials with <code>real</code> coefficients can also have <code>complex</code> roots.<br  />
 The algorithms of this module rely on finding the eigenvalues of a matrix \(A\) that are the roots of its <b>characteristic polynomial</b> \(f(x) = \mathrm{det}[A − xI]\).<br  />
 It can be shown that a monic polynomial \(f(x)\) is the characteristic polynomial of the special \(n\times n\) square <b>Frobenius Companion Matrix</b>,<br  />
  </p><p class="formulaDsp">
\begin{equation}
      C(f) =
      \begin{bmatrix}
          0 &amp; 0 &amp; \dots &amp; 0 &amp; -c_{0} \\
          1 &amp; 0 &amp; \dots &amp; 0 &amp; -c_{1} \\
          0 &amp; 1 &amp; \dots &amp; 0 &amp; -c_{2} \\
          \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \\
          0 &amp; 0 &amp; \dots &amp; 1 &amp; -c_{n-1}
      \end{bmatrix}
  \end{equation}
</p>
<p> Although the eigenvalue root-finding method can be slower than other polynomial root-finding methods, it is generally a more robust technique than others.<br  />
</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacepm__polynomial.html">pm_polynomial</a><br  />
 <a class="el" href="namespacepm__polynomial.html">pm_polynomial</a><br  />
 <a href="http://netlib.org/math">MATH77</a><br  />
 <a href="https://en.wikipedia.org/wiki/Root-finding_algorithms">Root-Finding Algorithms</a><br  />
 S. Goedecker, Remark on algorithms to find roots of polynomials, SIAM J. on Scientific Computing 15, 5 (Sept. 1994) 1058-1063.<br  />
 B. S. Garbow, J. M. Boyle, J. J. Dongarra, and C. B. Moler, Matrix Eigensystem Routines | EISPACK Guide Extension, Lecture Notes in Computer Science 51, Springer Verlag, Berlin (1977) 343 pages.<br  />
 B. T. Smith, J. M. Boyle, B. S. Garbow, Y. Ikebe, V. C. Klema, and C. B. Moler, Matrix Eigensystem Routines | EISPACK Guide, Lecture Notes in Computer Science 6, Springer Verlag, Berlin (1974) 387 pages.<br  />
</dd></dl>
<h2><a class="anchor" id="autotoc_md99"></a>
Polynomial root-finding: Jenkins–Traub method</h2>
<p >Given the <code>real</code> or <code>complex</code> coefficients \(c_i\) of a polynomial of degree \(n &gt; 0\),<br  />
  </p><p class="formulaDsp">
\begin{equation}
      f(x) = \sum_{i = 0}^{n} ~ c_i x^{i} ~,
  \end{equation}
</p>
<p> the root-finding procedures of this module also compute the \(n\) (potentially <code>complex</code>) roots of the polynomial \(f(x)\) using the Jenkins–Traub method.<br  />
 The roots are always returned as <code>complex</code> numbers as polynomials with <code>real</code> coefficients can also have <code>complex</code> roots.<br  />
 The algorithms of this module rely on a three-stage algorithm for finding roots of polynomials with <code>real</code> or <code>complex</code> coefficients as outlined in Jenkins and Traub (1970).<br  />
</p>
<dl class="section note"><dt>Note</dt><dd>Although the Jenkins–Traub method is a popular fairly robust method of polynomial root-finding, it can still fail to find roots of certain highly unstable polynomials, some of which are exemplified in the original paper of Jenkins and Traub (1970).<br  />
 In general, if the polynomial coefficients have highly variable number of significant digits, that is, they are of vastly different magnitudes (some very small and some very large), the Jenkins–Traub method might be prone to failure.<br  />
 This can happen when, for example, the difference in the number of significant digits of smallest and largest coefficients is comparable to the precision of the <code>real</code> or <code>complex</code> kind used to represent the coefficients.<br  />
 In such a case, using a higher-precision <code>real</code> or <code>complex</code> kind may resolve the instability.<br  />
</dd></dl>
<p><b>Which polynomial root-finding method should I use?</b><br  />
 If you have a polynomial of highly varying coefficients, then <a class="el" href="namespacepm__polynomial.html">Eigenvalue method</a> is likely going to be the more reliable approach.<br  />
 The <a class="el" href="namespacepm__polynomial.html">Jenkins-Traub</a> is also considered a relatively reliable fast <b>Sure-Fire</b> technique for finding the roots of polynomials.<br  />
</p>
<dl class="section remark"><dt>Remarks</dt><dd>The algorithms of this module that take polynomial coefficients of type <code>real</code> are expected to be generally up to four times faster than the corresponding algorithms that accept coefficients of type <code>complex</code>.<br  />
 The extent of the accuracy of above claim is yet to be tested for the specific implementations of this module.<br  />
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacepm__mathRoot.html">pm_mathRoot</a><br  />
 <a href="https://en.wikipedia.org/wiki/Root-finding_algorithms">Root-Finding Algorithms</a><br  />
 Jenkins and Traub, 1970, <em>A Three-Stage Algorithm for Real Polynomials Using Quadratic Iteration</em>, SIAM.<br  />
 Jenkins, ALGORITHM 493 - Zeros of a Real Polynomial [C2], ACM Transactions on Mathematical Software, Vol 1, No 2, June 1975.<br  />
</dd></dl>
<h2><a class="anchor" id="autotoc_md100"></a>
Polynomial root-finding: Laguerre method</h2>
<p >In numerical analysis, the Laguerre method is a root-finding algorithm tailored to polynomials.<br  />
 In other words, the Laguerre method can be used to numerically solve the equation \(p(x) = 0\) for a given polynomial \(p(x)\).<br  />
 One of the most useful properties of this method is that it is, from extensive empirical study, very close to being a <b>sure-fire</b> method, meaning that it is <b>almost guaranteed to always converge to some root of the polynomial, no matter what initial guess is chosen</b>.<br  />
 However, there are more efficient methods with which it is guaranteed to find all roots or all real roots.<br  />
 This method is named in honor of the French mathematician <a href="https://en.wikipedia.org/wiki/Edmond_Laguerre">Edmond Laguerre</a>.<br  />
</p>
<p >The algorithm of the Laguerre method to find one root of a polynomial \(p(x)\) of degree \(n\) is:<br  />
 </p><ol>
<li>
Choose an initial guess \(x_0\). </li>
<li>
For \(k = 0, 1, 2, \ldots\),<br  />
 <ol>
<li>
If \(p(x_{k})\) is very small, exit the loop.<br  />
 </li>
<li>
Calculate \(G = {\frac {p&#39;(x_{k})}{p(x_{k})}}\).<br  />
 </li>
<li>
Calculate \(H = G^{2} - {\frac {p&#39;&#39;(x_{k})}{p(x_{k})}}\).<br  />
 </li>
<li>
Calculate \(a = {\frac{n}{G\pm{\sqrt{(n - 1)(nH - G^{2})}}}}\), where the sign is chosen to give the denominator with the larger absolute value, to avoid catastrophic cancellation.<br  />
 </li>
<li>
Set \(x_{{k+1}}=x_{k} - a\).<br  />
 </li>
</ol>
</li>
<li>
Repeat until a is small enough or if the maximum number of iterations has been reached. </li>
</ol>
<p>If a root has been found, the corresponding linear factor can be removed from \(p\).<br  />
 This <b>deflation step</b> reduces the degree of the polynomial by one, so that eventually, approximations for all roots of \(p\) can be found.<br  />
 Note however that <b>deflation can lead to approximate factors that differ significantly from the corresponding exact factors</b>.<br  />
 This error is least if the roots are found in the order of increasing magnitude.<br  />
</p>
<dl class="test"><dt><b><a class="el" href="test.html#_test000718">Test:</a></b></dt><dd>test_pm_polynomial<br  />
</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000370">Todo:</a></b></dt><dd><span class="phigh">High Priority</span>: A generic interface <code>setPolyCoef(coef, root)</code> must be added that computes polynomial coefficients from its roots using recursive FFT-based polynomial multiplications.<br  />
 See the commented-out generic interface <code>setPolyCoef</code> within this module as the starting point.<br  />
</dd></dl>
<p ><br  />
<a class="anchor" id="final"></a><b>Final Remarks</b> <a href="#final">⛓</a> </p><hr  />
<p> If you believe this algorithm or its documentation can be improved, <b>we appreciate your contribution and help</b> <a href="https://github.com/cdslaborg/paramonte/tree/main/src/fortran/main/pm_polynomial.F90#L376 " target="_blank"><b>to edit this page's documentation and source file on GitHub</b></a>.<br  />
 For details on the naming abbreviations, see <a class="el" href="index.html#ParaMonteLangAbbreviationGuidlines">this page</a>.<br  />
 For details on the naming conventions, see <a class="el" href="index.html#ParaMonteLangNamingConventions">this page</a>.<br  />
 This software is distributed under the <a href="https://github.com/cdslaborg/paramonte#license" target="_blank">MIT license</a> <b>with additional terms outlined below.</b><br  />
</p><ol>
<li>
If you use any parts or concepts from this library to any extent, <b>please acknowledge the usage by citing the relevant</b> <a href="https://www.cdslab.org/paramonte/generic/latest/overview/preface/#how-to-acknowledge-the-use-of-the-paramonte-library-in-your-work" target="_blank"><b>publications of the ParaMonte library</b></a>.<br  />
</li>
<li>
If you regenerate any parts/ideas from this library in a programming environment other than those currently supported by this ParaMonte library (i.e., other than C, C++, Fortran, MATLAB, Python, R), <b>please also ask the end users to</b> <a href="https://www.cdslab.org/paramonte/generic/latest/overview/preface/#how-to-acknowledge-the-use-of-the-paramonte-library-in-your-work" target="_blank"><b>cite this original ParaMonte library</b></a>.<br  />
</li>
</ol>
<p>This software is available to the public under a highly permissive license.<br  />
Help us justify its continued development and maintenance by acknowledging its benefit to society, distributing it, and contributing to it.<br  />
 </p><dl class="section copyright"><dt>Copyright</dt><dd><a href="https://www.cdslab.org" target="_blank">Computational Data Science Lab</a></dd></dl>
<dl class="authors"><dt><b><a class="el" href="authors.html#_authors001079">Author:</a></b></dt><dd><a href="https://www.faba.one" target="_blank">Fatemeh Bagheri</a>, Tuesday 08:49 PM, August 10, 2021, Dallas, TX </dd></dl>
</div><h2 class="groupheader">Variable Documentation</h2>
<a id="a4bf1d29725012070ab27ec81918df46b" name="a4bf1d29725012070ab27ec81918df46b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bf1d29725012070ab27ec81918df46b">&#9670;&nbsp;</a></span>eigen</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structpm__polynomial_1_1eigen__type.html">eigen_type</a>), parameter pm_polynomial::eigen = <a class="el" href="structpm__polynomial_1_1eigen__type.html">eigen_type</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a scalar <code>parameter</code> object of type <a class="el" href="structpm__polynomial_1_1eigen__type.html">eigen_type</a> that is exclusively used to signify the use of Eigenvalue method of root-finding within an interface of a procedure of the ParaMonte library.<br  />
 </p>
<p >See the root-finding section in the documentation of <a class="el" href="namespacepm__polynomial.html">pm_polynomial</a> for more details about this root-finding method.<br  />
 For example usage, see the documentation of the target procedure requiring this object.<br  />
</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacepm__polynomial.html#a4bf1d29725012070ab27ec81918df46b">eigen</a><br  />
 <a class="el" href="namespacepm__polynomial.html#ac1f657eba9f64f4e251a5f1b67f0ba02">jenkins</a><br  />
 <a class="el" href="namespacepm__polynomial.html#ad7a9b1776fa3670d5b3cb401d91026e3">laguerre</a><br  />
 <a class="el" href="structpm__polynomial_1_1eigen__type.html">eigen_type</a><br  />
 <a class="el" href="structpm__polynomial_1_1jenkins__type.html">jenkins_type</a><br  />
 <a class="el" href="structpm__polynomial_1_1laguerre__type.html">laguerre_type</a><br  />
 <a class="el" href="structpm__polynomial_1_1method__type.html">method_type</a><br  />
</dd></dl>
<p><br  />
<a class="anchor" id="final-eigen"></a><b>Final Remarks</b> <a href="#final-eigen">⛓</a> </p><hr  />
<p> If you believe this algorithm or its documentation can be improved, <b>we appreciate your contribution and help</b> <a href="https://github.com/cdslaborg/paramonte/tree/main/src/fortran/main/pm_polynomial.F90#L3196 " target="_blank"><b>to edit this page's documentation and source file on GitHub</b></a>.<br  />
 For details on the naming abbreviations, see <a class="el" href="index.html#ParaMonteLangAbbreviationGuidlines">this page</a>.<br  />
 For details on the naming conventions, see <a class="el" href="index.html#ParaMonteLangNamingConventions">this page</a>.<br  />
 This software is distributed under the <a href="https://github.com/cdslaborg/paramonte#license" target="_blank">MIT license</a> <b>with additional terms outlined below.</b><br  />
</p><ol>
<li>
If you use any parts or concepts from this library to any extent, <b>please acknowledge the usage by citing the relevant</b> <a href="https://www.cdslab.org/paramonte/generic/latest/overview/preface/#how-to-acknowledge-the-use-of-the-paramonte-library-in-your-work" target="_blank"><b>publications of the ParaMonte library</b></a>.<br  />
</li>
<li>
If you regenerate any parts/ideas from this library in a programming environment other than those currently supported by this ParaMonte library (i.e., other than C, C++, Fortran, MATLAB, Python, R), <b>please also ask the end users to</b> <a href="https://www.cdslab.org/paramonte/generic/latest/overview/preface/#how-to-acknowledge-the-use-of-the-paramonte-library-in-your-work" target="_blank"><b>cite this original ParaMonte library</b></a>.<br  />
</li>
</ol>
<p>This software is available to the public under a highly permissive license.<br  />
Help us justify its continued development and maintenance by acknowledging its benefit to society, distributing it, and contributing to it.<br  />
 </p><dl class="section copyright"><dt>Copyright</dt><dd><a href="https://www.cdslab.org" target="_blank">Computational Data Science Lab</a></dd></dl>
<dl class="authors"><dt><b><a class="el" href="authors.html#_authors001093">Author:</a></b></dt><dd><a href="https://www.github.com/shahmoradi" target="_blank">Amir Shahmoradi</a>, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin </dd></dl>

<p class="definition">Definition at line <a class="el" href="pm__polynomial_8F90_source.html#l03200">3200</a> of file <a class="el" href="pm__polynomial_8F90_source.html">pm_polynomial.F90</a>.</p>

</div>
</div>
<a id="ac1f657eba9f64f4e251a5f1b67f0ba02" name="ac1f657eba9f64f4e251a5f1b67f0ba02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f657eba9f64f4e251a5f1b67f0ba02">&#9670;&nbsp;</a></span>jenkins</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structpm__polynomial_1_1jenkins__type.html">jenkins_type</a>), parameter pm_polynomial::jenkins = <a class="el" href="structpm__polynomial_1_1jenkins__type.html">jenkins_type</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a scalar <code>parameter</code> object of type <a class="el" href="structpm__polynomial_1_1jenkins__type.html">jenkins_type</a> that is exclusively used to signify the use of <b>Jenkins-Traub</b> method of root-finding within an interface of a procedure of the ParaMonte library.<br  />
 </p>
<p >See the root-finding section in the documentation of <a class="el" href="namespacepm__polynomial.html">pm_polynomial</a> for more details about this root-finding method.<br  />
 For example usage, see the documentation of the target procedure requiring this object.<br  />
</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacepm__polynomial.html#a4bf1d29725012070ab27ec81918df46b">eigen</a><br  />
 <a class="el" href="namespacepm__polynomial.html#ac1f657eba9f64f4e251a5f1b67f0ba02">jenkins</a><br  />
 <a class="el" href="namespacepm__polynomial.html#ad7a9b1776fa3670d5b3cb401d91026e3">laguerre</a><br  />
 <a class="el" href="structpm__polynomial_1_1eigen__type.html">eigen_type</a><br  />
 <a class="el" href="structpm__polynomial_1_1jenkins__type.html">jenkins_type</a><br  />
 <a class="el" href="structpm__polynomial_1_1laguerre__type.html">laguerre_type</a><br  />
 <a class="el" href="structpm__polynomial_1_1method__type.html">method_type</a><br  />
</dd></dl>
<p><br  />
<a class="anchor" id="final-jenkins"></a><b>Final Remarks</b> <a href="#final-jenkins">⛓</a> </p><hr  />
<p> If you believe this algorithm or its documentation can be improved, <b>we appreciate your contribution and help</b> <a href="https://github.com/cdslaborg/paramonte/tree/main/src/fortran/main/pm_polynomial.F90#L3254 " target="_blank"><b>to edit this page's documentation and source file on GitHub</b></a>.<br  />
 For details on the naming abbreviations, see <a class="el" href="index.html#ParaMonteLangAbbreviationGuidlines">this page</a>.<br  />
 For details on the naming conventions, see <a class="el" href="index.html#ParaMonteLangNamingConventions">this page</a>.<br  />
 This software is distributed under the <a href="https://github.com/cdslaborg/paramonte#license" target="_blank">MIT license</a> <b>with additional terms outlined below.</b><br  />
</p><ol>
<li>
If you use any parts or concepts from this library to any extent, <b>please acknowledge the usage by citing the relevant</b> <a href="https://www.cdslab.org/paramonte/generic/latest/overview/preface/#how-to-acknowledge-the-use-of-the-paramonte-library-in-your-work" target="_blank"><b>publications of the ParaMonte library</b></a>.<br  />
</li>
<li>
If you regenerate any parts/ideas from this library in a programming environment other than those currently supported by this ParaMonte library (i.e., other than C, C++, Fortran, MATLAB, Python, R), <b>please also ask the end users to</b> <a href="https://www.cdslab.org/paramonte/generic/latest/overview/preface/#how-to-acknowledge-the-use-of-the-paramonte-library-in-your-work" target="_blank"><b>cite this original ParaMonte library</b></a>.<br  />
</li>
</ol>
<p>This software is available to the public under a highly permissive license.<br  />
Help us justify its continued development and maintenance by acknowledging its benefit to society, distributing it, and contributing to it.<br  />
 </p><dl class="section copyright"><dt>Copyright</dt><dd><a href="https://www.cdslab.org" target="_blank">Computational Data Science Lab</a></dd></dl>
<dl class="authors"><dt><b><a class="el" href="authors.html#_authors001095">Author:</a></b></dt><dd><a href="https://www.github.com/shahmoradi" target="_blank">Amir Shahmoradi</a>, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin </dd></dl>

<p class="definition">Definition at line <a class="el" href="pm__polynomial_8F90_source.html#l03258">3258</a> of file <a class="el" href="pm__polynomial_8F90_source.html">pm_polynomial.F90</a>.</p>

</div>
</div>
<a id="ad7a9b1776fa3670d5b3cb401d91026e3" name="ad7a9b1776fa3670d5b3cb401d91026e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7a9b1776fa3670d5b3cb401d91026e3">&#9670;&nbsp;</a></span>laguerre</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structpm__polynomial_1_1laguerre__type.html">laguerre_type</a>), parameter pm_polynomial::laguerre = <a class="el" href="structpm__polynomial_1_1laguerre__type.html">laguerre_type</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a scalar <code>parameter</code> object of type <a class="el" href="structpm__polynomial_1_1laguerre__type.html">laguerre_type</a> that is exclusively used to signify the use of <b>Laguerre</b> method of root-finding within an interface of a procedure of the ParaMonte library.<br  />
 </p>
<p >See the root-finding section in the documentation of <a class="el" href="namespacepm__polynomial.html">pm_polynomial</a> for more details about this root-finding method.<br  />
 For example usage, see the documentation of the target procedure requiring this object.<br  />
</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacepm__polynomial.html#a4bf1d29725012070ab27ec81918df46b">eigen</a><br  />
 <a class="el" href="namespacepm__polynomial.html#ac1f657eba9f64f4e251a5f1b67f0ba02">jenkins</a><br  />
 <a class="el" href="namespacepm__polynomial.html#ad7a9b1776fa3670d5b3cb401d91026e3">laguerre</a><br  />
 <a class="el" href="structpm__polynomial_1_1eigen__type.html">eigen_type</a><br  />
 <a class="el" href="structpm__polynomial_1_1jenkins__type.html">jenkins_type</a><br  />
 <a class="el" href="structpm__polynomial_1_1laguerre__type.html">laguerre_type</a><br  />
 <a class="el" href="structpm__polynomial_1_1method__type.html">method_type</a><br  />
</dd></dl>
<p><br  />
<a class="anchor" id="final-laguerre"></a><b>Final Remarks</b> <a href="#final-laguerre">⛓</a> </p><hr  />
<p> If you believe this algorithm or its documentation can be improved, <b>we appreciate your contribution and help</b> <a href="https://github.com/cdslaborg/paramonte/tree/main/src/fortran/main/pm_polynomial.F90#L3312 " target="_blank"><b>to edit this page's documentation and source file on GitHub</b></a>.<br  />
 For details on the naming abbreviations, see <a class="el" href="index.html#ParaMonteLangAbbreviationGuidlines">this page</a>.<br  />
 For details on the naming conventions, see <a class="el" href="index.html#ParaMonteLangNamingConventions">this page</a>.<br  />
 This software is distributed under the <a href="https://github.com/cdslaborg/paramonte#license" target="_blank">MIT license</a> <b>with additional terms outlined below.</b><br  />
</p><ol>
<li>
If you use any parts or concepts from this library to any extent, <b>please acknowledge the usage by citing the relevant</b> <a href="https://www.cdslab.org/paramonte/generic/latest/overview/preface/#how-to-acknowledge-the-use-of-the-paramonte-library-in-your-work" target="_blank"><b>publications of the ParaMonte library</b></a>.<br  />
</li>
<li>
If you regenerate any parts/ideas from this library in a programming environment other than those currently supported by this ParaMonte library (i.e., other than C, C++, Fortran, MATLAB, Python, R), <b>please also ask the end users to</b> <a href="https://www.cdslab.org/paramonte/generic/latest/overview/preface/#how-to-acknowledge-the-use-of-the-paramonte-library-in-your-work" target="_blank"><b>cite this original ParaMonte library</b></a>.<br  />
</li>
</ol>
<p>This software is available to the public under a highly permissive license.<br  />
Help us justify its continued development and maintenance by acknowledging its benefit to society, distributing it, and contributing to it.<br  />
 </p><dl class="section copyright"><dt>Copyright</dt><dd><a href="https://www.cdslab.org" target="_blank">Computational Data Science Lab</a></dd></dl>
<dl class="authors"><dt><b><a class="el" href="authors.html#_authors001097">Author:</a></b></dt><dd><a href="https://www.github.com/shahmoradi" target="_blank">Amir Shahmoradi</a>, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin </dd></dl>

<p class="definition">Definition at line <a class="el" href="pm__polynomial_8F90_source.html#l03316">3316</a> of file <a class="el" href="pm__polynomial_8F90_source.html">pm_polynomial.F90</a>.</p>

</div>
</div>
<a id="a7ed954ba0101852d40ea302341567ac1" name="a7ed954ba0101852d40ea302341567ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed954ba0101852d40ea302341567ac1">&#9670;&nbsp;</a></span>MODULE_NAME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">character(*, SK), parameter pm_polynomial::MODULE_NAME = &quot;@pm_polynomial&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="pm__polynomial_8F90_source.html#l00389">389</a> of file <a class="el" href="pm__polynomial_8F90_source.html">pm_polynomial.F90</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
    <!-- start footer part -->
    <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
      <ul>
        <li class="navelem"><a class="el" href="namespacepm__polynomial.html">pm_polynomial</a></li>
        <li class="footer">Generated on Sat May 18 2024 21:35:49 for ParaMonte Fortran 2.0.0 by <a href="http://www.doxygen.org/index.html" target="_blank"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
      </ul>
    </div>
    <div style="color: #ffffff; float: none; width: 100%;">
        <span style="font-size:0.8em">
            <script type="text/javascript">
                var sc_project=12178963; 
                var sc_invisible=1; 
                var sc_security="e0dfe0f9"; 
                var sc_text=3; 
                var scJsHost = "https://";
                document.write("<sc"+"ript type='text/javascript' src='" +
                scJsHost+
                "statcounter.com/counter/counter.js'></"+"script>");
            </script>
        </span>
    </div>
</body>
</html>
