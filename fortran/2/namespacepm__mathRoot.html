<!-- HTML header for doxygen 1.9.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="$langISO">
<head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=11"/>
    <meta name="generator" content="Doxygen 1.9.3"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>ParaMonte Fortran 2.0.0: pm_mathRoot Module Reference</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
   TeX: { Macros: {
    up: ["{{\\mathrm{#1}}}",1],
    bs: ["{{\\boldsymbol{#1}}}",1],
    ms: ["{\\texttt{#1}}",1],
    diff: "{{\\mathrm{d}}}",
    bu: ["{{\\boldsymbol{\\mathrm{#1}}}}",1],
    sline: "{\\rule{\\textwidth}{1pt}}",
    sphere: "{{\\mathcal{S}}}",
    ell: "{{\\mathcal{E}}}",
    ndim: "{{\\ms{ndim}}}",
    gramian: "{{\\mathcal{G}}}",
    mat: ["{{\\boldsymbol{\\mathrm {#1}}}}",1],
    unit: ["{{\\boldsymbol{\\widehat{\\mathrm{#1}}}}}",1],
    ebreak: "{{E_\\ms{b}}}",
    xbreak: "{{x_\\ms{b}}}",
    efold: "{{E_\\ms{f}}}",
    epeak: "{{E_\\ms{p}}}",
    phot: "{{\\ms{ph}}}",
    ergs: "{{\\ms{ergs}}}",
    sergs: "{{S_{\\ms{ergs}}}}",
    sphot: "{{S_{\\phot}}}",
    kev: "{{\\ms{keV}}}",
    det: "{{\\ms{det}}}",
    var: "{{\\ms{var}}}",
  } }
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="html_extra_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
        <div id="titlearea">
            <table cellspacing="0" cellpadding="0" stype="z-index:-1;">
                <tbody>
                    <tr id="projectrow">
                        <td id="projectlogo">
                            <a href="https://www.cdslab.org/paramonte/" target="_blank"><img alt="Logo" src="logo.png"/></a>
                        </td>
                        <td id="projectalign">
                            <div id="projectname">
                                ParaMonte Fortran 2.0.0
                            </div>
                            <div id="projectbrief">
                                Parallel Monte Carlo and Machine Learning Library<br><a href="../latest/index.html" target="_blank">See the latest version documentation.</a>
                            </div>
                        </td>
                        <!--
                        <td id="projectalign" style="padding-left: 0.5em;">
                            <a href="https://github.com/cdslaborg/paramonte/releases" target="_blank">
                                <div id="projectname">
                                    <span id="projectbrief">Parallel Monte Carlo &#38;</span>
                                    <span id="projectbrief">Machine Learning Library</span>
                                    <span id="projectbrief">Version </span>
                                </div>
                            </a>
                        </td>
                        <td style="padding-left: 0.5em;">
                            <div id="projectbrief">Parallel Monte Carlo and Machine Learning Library</div>
                        </td>
                        -->
                    </tr>
                </tbody>
            </table>
        </div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacepm__mathRoot.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Types</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">pm_mathRoot Module Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This module contains classes and procedures for computing the roots of one-dimensional continuous mathematical functions using various root-finding methods.<br  />
  
<a href="namespacepm__mathRoot.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Types</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpm__mathRoot_1_1bisection__type.html">bisection_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a concrete derived type whose instances are exclusively used to signify the use of the Bisection method of root-finding.<br  />
  <a href="structpm__mathRoot_1_1bisection__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpm__mathRoot_1_1bracket__type.html">bracket_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an <code>abstract</code> derived type for constructing concrete derived types to distinguish various procedure signatures that require <b>bracketing</b> root-finding methods (e.g., Bisection, False Position, ...).<br  />
  <a href="structpm__mathRoot_1_1bracket__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpm__mathRoot_1_1brent__type.html">brent_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a concrete derived type whose instances are exclusively used to signify the use of the Brent method of root-finding.<br  />
  <a href="structpm__mathRoot_1_1brent__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpm__mathRoot_1_1false__type.html">false_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a concrete derived type whose instances are exclusively used to signify the use of the False-Position method of root-finding.<br  />
  <a href="structpm__mathRoot_1_1false__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacepm__mathRoot_1_1getRoot.html">getRoot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate and return a root of a specified continuous real-valued one-dimensional mathematical function such that \(f(\mathrm{root}) = 0\) with the user-specified or the default root-finding method.<br  />
  <a href="interfacepm__mathRoot_1_1getRoot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpm__mathRoot_1_1halley__type.html">halley_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a concrete derived type whose instances are exclusively used to signify the use of the Halley method of root-finding.<br  />
  <a href="structpm__mathRoot_1_1halley__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpm__mathRoot_1_1hybrid__type.html">hybrid_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an <code>abstract</code> derived type for constructing concrete derived types to distinguish various procedure signatures that require <b>iterative</b> root-finding methods (e.g., Secant, Newton, ...).<br  />
  <a href="structpm__mathRoot_1_1hybrid__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpm__mathRoot_1_1iteration__type.html">iteration_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an <code>abstract</code> derived type for constructing concrete derived types to distinguish various procedure signatures that require <b>iterative</b> root-finding methods (e.g., Secant, Newton, ...).<br  />
  <a href="structpm__mathRoot_1_1iteration__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpm__mathRoot_1_1method__type.html">method_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an <code>abstract</code> derived type for constructing concrete derived types to distinguish various procedure signatures that require root-finding methods (e.g., Bisection, False Position, Secant, Newton, Brent, Ridders, ...).<br  />
  <a href="structpm__mathRoot_1_1method__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpm__mathRoot_1_1newton__type.html">newton_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a concrete derived type whose instances are exclusively used to signify the use of the Newton method of root-finding.<br  />
  <a href="structpm__mathRoot_1_1newton__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpm__mathRoot_1_1ridders__type.html">ridders_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a concrete derived type whose instances are exclusively used to signify the use of the Ridders method of root-finding.<br  />
  <a href="structpm__mathRoot_1_1ridders__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpm__mathRoot_1_1schroder__type.html">schroder_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a concrete derived type whose instances are exclusively used to signify the use of the Schroder method of root-finding.<br  />
  <a href="structpm__mathRoot_1_1schroder__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpm__mathRoot_1_1secant__type.html">secant_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a concrete derived type whose instances are exclusively used to signify the use of the Secant method of root-finding.<br  />
  <a href="structpm__mathRoot_1_1secant__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacepm__mathRoot_1_1setRoot.html">setRoot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a root of a specified continuous real-valued one-dimensional mathematical function such that \(f(\mathrm{root}) = 0\) with the user-specified or the default root-finding method.<br  />
  <a href="interfacepm__mathRoot_1_1setRoot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpm__mathRoot_1_1toms748__type.html">toms748_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a concrete derived type whose instances are exclusively used to signify the use of the TOMS748 method of root-finding.<br  />
  <a href="structpm__mathRoot_1_1toms748__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:af4b747491d87135fb50b95df1746e856"><td class="memItemLeft" align="right" valign="top">character(*, SK), parameter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepm__mathRoot.html#af4b747491d87135fb50b95df1746e856">MODULE_NAME</a> = &quot;@pm_mathRoot&quot;</td></tr>
<tr class="separator:af4b747491d87135fb50b95df1746e856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3409e5000efdde261d2f3265678d0436"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structpm__mathRoot_1_1brent__type.html">brent_type</a>), parameter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepm__mathRoot.html#a3409e5000efdde261d2f3265678d0436">brent</a> = <a class="el" href="structpm__mathRoot_1_1brent__type.html">brent_type</a>()</td></tr>
<tr class="memdesc:a3409e5000efdde261d2f3265678d0436"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a scalar <code>parameter</code> object of type <a class="el" href="structpm__mathRoot_1_1brent__type.html">brent_type</a> that is exclusively used to signify the use of Brent method of root-finding within an interface of a procedure of the ParaMonte library.<br  />
  <a href="namespacepm__mathRoot.html#a3409e5000efdde261d2f3265678d0436">More...</a><br /></td></tr>
<tr class="separator:a3409e5000efdde261d2f3265678d0436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a471263361906d447d3ec06b1bf3eef0b"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structpm__mathRoot_1_1toms748__type.html">toms748_type</a>), parameter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepm__mathRoot.html#a471263361906d447d3ec06b1bf3eef0b">toms748</a> = <a class="el" href="structpm__mathRoot_1_1toms748__type.html">toms748_type</a>()</td></tr>
<tr class="memdesc:a471263361906d447d3ec06b1bf3eef0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a scalar <code>parameter</code> object of type <a class="el" href="structpm__mathRoot_1_1toms748__type.html">toms748_type</a> that is exclusively used to signify the use of TOMS748 method of root-finding within an interface of a procedure of the ParaMonte library.<br  />
  <a href="namespacepm__mathRoot.html#a471263361906d447d3ec06b1bf3eef0b">More...</a><br /></td></tr>
<tr class="separator:a471263361906d447d3ec06b1bf3eef0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e707e2dada15fddfbd434f621f6b1ef"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structpm__mathRoot_1_1false__type.html">false_type</a>), parameter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepm__mathRoot.html#a7e707e2dada15fddfbd434f621f6b1ef">false</a> = <a class="el" href="structpm__mathRoot_1_1false__type.html">false_type</a>()</td></tr>
<tr class="memdesc:a7e707e2dada15fddfbd434f621f6b1ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a scalar <code>parameter</code> object of type <a class="el" href="structpm__mathRoot_1_1false__type.html">false_type</a> that is exclusively used to signify the use of False-Position method of root-finding within an interface of a procedure of the ParaMonte library.<br  />
  <a href="namespacepm__mathRoot.html#a7e707e2dada15fddfbd434f621f6b1ef">More...</a><br /></td></tr>
<tr class="separator:a7e707e2dada15fddfbd434f621f6b1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeada6d7662ab9da56ae68e165f35be3b"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structpm__mathRoot_1_1secant__type.html">secant_type</a>), parameter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepm__mathRoot.html#aeada6d7662ab9da56ae68e165f35be3b">secant</a> = <a class="el" href="structpm__mathRoot_1_1secant__type.html">secant_type</a>()</td></tr>
<tr class="memdesc:aeada6d7662ab9da56ae68e165f35be3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a scalar <code>parameter</code> object of type <a class="el" href="structpm__mathRoot_1_1secant__type.html">secant_type</a> that is exclusively used to signify the use of Secant method of root-finding within an interface of a procedure of the ParaMonte library.<br  />
  <a href="namespacepm__mathRoot.html#aeada6d7662ab9da56ae68e165f35be3b">More...</a><br /></td></tr>
<tr class="separator:aeada6d7662ab9da56ae68e165f35be3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab1ab19049b29b25610aef4eaedfd3e"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structpm__mathRoot_1_1newton__type.html">newton_type</a>), parameter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepm__mathRoot.html#a4ab1ab19049b29b25610aef4eaedfd3e">newton</a> = <a class="el" href="structpm__mathRoot_1_1newton__type.html">newton_type</a>()</td></tr>
<tr class="memdesc:a4ab1ab19049b29b25610aef4eaedfd3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a scalar <code>parameter</code> object of type <a class="el" href="structpm__mathRoot_1_1newton__type.html">newton_type</a> that is exclusively used to signify the use of Newton method of root-finding within an interface of a procedure of the ParaMonte library.<br  />
  <a href="namespacepm__mathRoot.html#a4ab1ab19049b29b25610aef4eaedfd3e">More...</a><br /></td></tr>
<tr class="separator:a4ab1ab19049b29b25610aef4eaedfd3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add19d3b40dedb3c60958cb830fdcd2cc"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structpm__mathRoot_1_1halley__type.html">halley_type</a>), parameter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepm__mathRoot.html#add19d3b40dedb3c60958cb830fdcd2cc">halley</a> = <a class="el" href="structpm__mathRoot_1_1halley__type.html">halley_type</a>()</td></tr>
<tr class="memdesc:add19d3b40dedb3c60958cb830fdcd2cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a scalar <code>parameter</code> object of type <a class="el" href="structpm__mathRoot_1_1halley__type.html">halley_type</a> that is exclusively used to signify the use of Halley method of root-finding within an interface of a procedure of the ParaMonte library.<br  />
  <a href="namespacepm__mathRoot.html#add19d3b40dedb3c60958cb830fdcd2cc">More...</a><br /></td></tr>
<tr class="separator:add19d3b40dedb3c60958cb830fdcd2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea044c5c7944004b6c2f9c050e3cf810"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structpm__mathRoot_1_1schroder__type.html">schroder_type</a>), parameter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepm__mathRoot.html#aea044c5c7944004b6c2f9c050e3cf810">schroder</a> = <a class="el" href="structpm__mathRoot_1_1schroder__type.html">schroder_type</a>()</td></tr>
<tr class="memdesc:aea044c5c7944004b6c2f9c050e3cf810"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a scalar <code>parameter</code> object of type <a class="el" href="structpm__mathRoot_1_1schroder__type.html">schroder_type</a> that is exclusively used to signify the use of Schroder method of root-finding within an interface of a procedure of the ParaMonte library.<br  />
  <a href="namespacepm__mathRoot.html#aea044c5c7944004b6c2f9c050e3cf810">More...</a><br /></td></tr>
<tr class="separator:aea044c5c7944004b6c2f9c050e3cf810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e803f26dcf937fbb6158b0dbbd94960"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structpm__mathRoot_1_1ridders__type.html">ridders_type</a>), parameter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepm__mathRoot.html#a3e803f26dcf937fbb6158b0dbbd94960">ridders</a> = <a class="el" href="structpm__mathRoot_1_1ridders__type.html">ridders_type</a>()</td></tr>
<tr class="memdesc:a3e803f26dcf937fbb6158b0dbbd94960"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a scalar <code>parameter</code> object of type <a class="el" href="structpm__mathRoot_1_1ridders__type.html">ridders_type</a> that is exclusively used to signify the use of Ridders method of root-finding within an interface of a procedure of the ParaMonte library.<br  />
  <a href="namespacepm__mathRoot.html#a3e803f26dcf937fbb6158b0dbbd94960">More...</a><br /></td></tr>
<tr class="separator:a3e803f26dcf937fbb6158b0dbbd94960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5504dde0cb89575fd6f0882739a0d7b7"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structpm__mathRoot_1_1bisection__type.html">bisection_type</a>), parameter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepm__mathRoot.html#a5504dde0cb89575fd6f0882739a0d7b7">bisection</a> = <a class="el" href="structpm__mathRoot_1_1bisection__type.html">bisection_type</a>()</td></tr>
<tr class="memdesc:a5504dde0cb89575fd6f0882739a0d7b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a scalar <code>parameter</code> object of type <a class="el" href="structpm__mathRoot_1_1bisection__type.html">bisection_type</a> that is exclusively used to signify the use of Bisection method of root-finding within an interface of a procedure of the ParaMonte library.<br  />
  <a href="namespacepm__mathRoot.html#a5504dde0cb89575fd6f0882739a0d7b7">More...</a><br /></td></tr>
<tr class="separator:a5504dde0cb89575fd6f0882739a0d7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >This module contains classes and procedures for computing the roots of one-dimensional continuous mathematical functions using various root-finding methods.<br  />
 </p>
<p >In mathematics and computing, a <b>root-finding</b> algorithm is an algorithm for finding <b>zeros</b>, also called <b>roots</b>, of continuous functions.<br  />
 A zero of a function \(f\), from the real numbers to real numbers or from the complex numbers to the complex numbers, is a number \(x\) such that \(f(x) = 0\).<br  />
 As, generally, the zeros of a function cannot be computed exactly nor expressed in closed form, root-finding algorithms provide approximations to zeros expressed either as floating-point numbers or as small isolating intervals, or disks for complex roots.<br  />
 Solving an equation \(f(x) = g(x)\) is the same as finding the roots of the function \(h(x) = f(x) – g(x)\).<br  />
 Thus root-finding algorithms allow solving any equation defined by continuous functions.<br  />
 However, most root-finding algorithms do not guarantee that they will find all the roots.<br  />
 If such an algorithm does not find any root, it does not mean that no root exists.<br  />
</p>
<p >Most numerical root-finding methods use <b>iteration</b>, producing a sequence of numbers that hopefully converges towards the root as its limit.<br  />
 They require one or more initial guesses of the root as starting values, then each iteration of the algorithm produces a successively more accurate approximation to the root.<br  />
 Since the iteration must be stopped at some point, these methods produce an approximation to the root, not an exact solution.<br  />
</p>
<h1><a class="anchor" id="autotoc_md43"></a>
Bracketing methods</h1>
<p >Bracketing methods determine successively smaller intervals (brackets) that contain a root.<br  />
 When the interval is small enough, then a root has been found.<br  />
 They generally use the intermediate value theorem, which asserts that if a continuous function has values of opposite signs at the end points of an interval, then the function has at least one root in the interval.<br  />
 Therefore, they <em>require to start with an interval such that the function takes opposite signs at the end points of the interval</em>.<br  />
 There are <a href="https://en.wikipedia.org/wiki/Descartes%27_rule_of_signs">other methods</a> for getting information on the number of roots of polynomials in an interval.<br  />
</p>
<h2><a class="anchor" id="autotoc_md44"></a>
Bisection method</h2>
<p >The Bisection method consists of repeatedly bisecting a pre-specified interval known to contain at least one root.<br  />
 The method selects the subinterval in which the function changes sign, and therefore must contain a root.<br  />
 It is a very simple and robust, but relatively slow root-finding method.<br  />
 As such, it is frequently used to obtain a rough approximation to the solution of a given root-finding problem.<br  />
 The approximate solution is then used as a starting point for more rapidly converging methods.<br  />
</p>
<p ><b>The Bisection Algorithm</b><br  />
 The Bisection method numerically solves the real-valued equation \(f(x) = 0\).<br  />
 The continuous function \(f\) is defined on a search interval \([a, b]\) with \(f(a)\) and \(f(b)\) having opposite signs.<br  />
 In such a case \(a\) and \(b\) are said to <b>bracket a root</b> \(f\) must have at least one root in the search interval \((a, b)\).<br  />
 At each step, the method divides the interval in two parts (halves) by computing the midpoint \(c = (a + b) / 2\) of the interval and \(f(c)\).<br  />
 If \(c\) is a root then the process has succeeded and stops.<br  />
 Otherwise, there are now only two possibilities:<br  />
 </p><ol>
<li>
\(f(a)\) and \(f(c)\) have opposite signs and bracket a root.<br  />
 </li>
<li>
\(f(c)\) and \(f(b)\) have opposite signs and bracket a root.<br  />
 </li>
</ol>
<p>If the function has the same sign at the endpoints of an interval, the endpoints may or may not bracket roots of the function.<br  />
 The Bisection method selects the subinterval that is guaranteed to be a bracket as the new interval to be used in the next step.<br  />
 In this way an interval that contains a zero of \(f\) is reduced in width by half at each step.<br  />
 The process is continued until the interval is sufficiently small.<br  />
</p>
<dl class="section remark"><dt>Remarks</dt><dd>The finite precision of computers can cause serious problems for convergence of the Bisection method.<br  />
 As such, the implementations of the method frequently include convergence tests or limits to the number of iterations.<br  />
 Although \(f\) is continuous, the finite precision of computer can preclude a function value ever being zero.<br  />
 Additionally, the difference between the search interval limits cannot be less than the floating point precision of the computer.<br  />
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The Bisection method is also known as the <b>Interval-Halving method</b>, the <b>Binary Search method</b>, or the <b>Dichotomy method</b>.</dd></dl>
<h2><a class="anchor" id="autotoc_md45"></a>
False position (regula falsi) method</h2>
<p >The False Position method is a root-finding algorithm is a very old method for solving an equation with one unknown.<br  />
 In simple terms, the method is the trial and error technique of using test (<em>false</em>) values for the variable and then adjusting the test value according to the outcome.<br  />
 This is sometimes also referred to as <em>guess and check</em>.<br  />
 Versions of the method predate the advent of algebra and the use of equations.<br  />
</p>
<p ><b>The False Position Algorithm</b><br  />
</p>
<p >The Regula Falsi method calculates the new solution estimate as the x-intercept of the line segment joining the endpoints of the function on the current bracketing interval of the root.<br  />
 Essentially, the root is being approximated by replacing the actual function by a line segment on the bracketing interval and then using the classical double false position formula on that line segment.<br  />
</p>
<div class="image">
<img src="pm_mathRoot@false.png" alt="" width="500"/>
</div>
<p >Suppose that in the \(k\)-th iteration the bracketing interval is \((a_k, b_k)\) as illustrated above.<br  />
 Construct the line through the points \((a_k, f(a_k))\) and \((b_k, f(b_k))\).<br  />
 The equation of the line is given by,<br  />
  </p><p class="formulaDsp">
\begin{equation}
      \large
      y - f(b_k) = \frac{f(b_k) - f(a_k)}{b_k - a_k} (x - b_k) ~.
  \end{equation}
</p>
<p> Now choose \(c_k\) to be the x-intercept of this line, that is, the value of \(x\) for which \(y = 0\), and substitute these values to obtain,<br  />
  </p><p class="formulaDsp">
\begin{equation}
      \large
      f(b_k) + \frac{f(b_k) - f(a_k)}{b_k - a_k}(c_k - b_k) = 0 ~.
  \end{equation}
</p>
<p> Solving this equation for \(c_k\) yields,<br  />
  </p><p class="formulaDsp">
\begin{equation}
      \large
      c_k = b_k - f(b_k) \frac{b_k - a_k}{f(b_k) - f(a_k)} = \frac{a_k f(b_k) - b_k f(a_k)}{f(b_k) - f(a_k)} ~.
  \end{equation}
</p>
<p> The last symmetrical form has a computational advantage;<br  />
 As a solution is approached, \(a_k\) and \(b_k\) will be very close together and nearly always of the same sign.<br  />
 Such a subtraction can lose significant digits.<br  />
 Because \(f(b_k)\) and \(f(a_k)\) are always of opposite sign, the subtraction in the numerator of the improved formula is effectively an addition (as is the subtraction in the denominator).<br  />
 At iteration number \(k\), the number \(c_k\) is calculated as above and then, if \(f(a_k)\) and \(f(c_k)\) have the same sign, set \(a_k + 1 = c_k\) and \(b_k + 1 = b_k\).<br  />
 Otherwise set \(a_k + 1 = a_k\) and \(b_k + 1 = c_k\).<br  />
 This process is repeated until the root is approximated sufficiently well.<br  />
 The above formula is also used in the Secant method.<br  />
 However, the Secant method always retains the last two computed points.<br  />
 Therefore, while the Secant method is slightly faster, it does not preserve the root bracketing and may not converge.<br  />
 The fact that <b>the Regula Falsi root-finding method always converges</b> makes it a good choice when speed is needed.<br  />
 However, its rate of convergence can drop below that of the bisection method.<br  />
</p>
<p ><b>The Convergence of the False Position Algorithm</b><br  />
</p>
<p >The convergence rate of the False Position method can be better than the Bisection method but is worse than the Secant method.<br  />
 The method often has a superlinear convergence rate.<br  />
 However, estimation of the exact order of convergence is difficult (e.g., see Numerical Recipes in Fortran by Press et al. 1992 for a discussion).<br  />
</p>
<dl class="section remark"><dt>Remarks</dt><dd>The finite precision of computers can cause problems for convergence of the False Position method.<br  />
 As such, the implementations of the method frequently include convergence tests or limits to the number of iterations.<br  />
 Although \(f\) is continuous, the finite precision of computer can preclude a function value ever being zero.<br  />
 Additionally, the difference between the search interval limits cannot be less than the floating point precision of the computer.<br  />
</dd></dl>
<h1><a class="anchor" id="autotoc_md46"></a>
Iterative methods</h1>
<h2><a class="anchor" id="autotoc_md47"></a>
The Secant method</h2>
<p >The Secant method is a root-finding algorithm that uses a succession of roots of secant lines to better approximate a root of a function.<br  />
 The Secant method can be thought of as a finite-difference approximation of the <a class="el" href="namespacepm__mathRoot.html">Newton method</a>.<br  />
 However, the Secant method predates the Newton method by over 3000 years.<br  />
</p>
<p ><b>The Secant Algorithm</b><br  />
 The Secant method is defined by the following recursive relation,<br  />
  </p><p class="formulaDsp">
\begin{eqnarray}
      \large
      x_{n}
      &amp;=&amp; x_{n-1} - f(x_{n-1}) \frac{x_{n-1} - x_{n-2}} {f(x_{n-1}) - f(x_{n-2})} ~, \\
      &amp;=&amp; \frac {x_{n-2} f(x_{n-1}) - x_{n-1} f(x_{n-2})} {f(x_{n-1}) - f(x_{n-2})} ~,
  \end{eqnarray}
</p>
<p> where the two initial values \(x_0\) and \(x_1\) should be chosen close to the desired zero.<br  />
</p>
<dl class="section remark"><dt>Remarks</dt><dd>Unlike the other iterative root-finding methods such as the <a class="el" href="namespacepm__mathRoot.html">Bisection</a> or the <a class="el" href="namespacepm__mathRoot.html">Brent</a> methods, the Secant method does <b>not</b> require the initial starting values \(x_0\) and \(x_1\) to bracket the root of the function.</dd></dl>
<p><b>Convergence of the Secant Algorithm</b><br  />
 The iterates \(x_n\) of the Secant method converge to a root of a continuous function if the initial values \(x_0\) and \(x_1\) are sufficiently close to the root.<br  />
 The order of convergence is the Golden Ratio \(\phi = 1.618\), so that the limiting error in the root is,<br  />
  </p><p class="formulaDsp">
\begin{equation}
      \large
      \lim_{k\rightarrow+\infty} |\epsilon_{k}| \propto |\epsilon_{k - 1}|^{1.618} ~.
  \end{equation}
</p>
<p> The rate of convergence is therefore faster than the <a class="el" href="namespacepm__mathRoot.html">Bisection</a>.<br  />
 In particular, the convergence is <b>super-linear</b>, but <b>sub-quadratic</b>.<br  />
 This convergence rate only holds under some technical conditions, namely the <b>function must be twice continuously differentiable and the root in question be simple</b> (i.e., with multiplicity 1).<br  />
 If the initial values are not close enough to the root, then there is no guarantee that the Secant method converges.<br  />
 There is no general definition of <em>close enough</em>, but the criterion has to do with how <em>wiggly</em> the function is on the interval \([x_0, x_1]\).<br  />
 For example, if the function is differentiable on the interval and there is a point where \(f′(x) = 0\) on the interval, then the algorithm may not converge.<br  />
 For functions that are not sufficiently continuous, the algorithm can therefore not be guaranteed to converge: Local behavior might send it off towards infinity.<br  />
</p>
<dl class="section remark"><dt>Remarks</dt><dd>The finite precision of computers can cause problems for convergence of the Secant method.<br  />
 As such, the implementations of the method frequently include convergence tests or limits to the number of iterations.<br  />
 Although \(f\) is continuous, the finite precision of computer can preclude a function value ever being zero.<br  />
 Additionally, the difference between the search interval limits cannot be less than the floating point precision of the computer.<br  />
</dd></dl>
<h2><a class="anchor" id="autotoc_md48"></a>
The Newton method</h2>
<p >The Newton method, also known as the Newton–Raphson method, named after Isaac Newton and Joseph Raphson, is a root-finding algorithm which produces successively better approximations to the roots (or zeroes) of a real-valued function.<br  />
</p>
<p ><b>The Newton Algorithm</b><br  />
</p>
<p >The most basic version of the method starts with,<br  />
 </p><ol>
<li>
a single-variable function \(f(x)\) defined for a real variable \(x\),<br  />
 </li>
<li>
the function derivative \(f′(x)\),<br  />
 </li>
<li>
an initial guess \(x_0\) for a root of \(f(x)\).<br  />
 </li>
</ol>
<p>If the function satisfies sufficient assumptions and the initial guess is close, then,<br  />
  </p><p class="formulaDsp">
\begin{equation}
      \large
      x_{1} = x_{0} - \frac{f(x_{0})}{f&#39;(x_{0})} ~,
  \end{equation}
</p>
<p> is a better approximation of the root than \(x_0\) (as illustrated below).<br  />
</p>
<div class="image">
<img src="pm_mathRoot@newton.gif" alt="" width="500"/>
</div>
<p >Geometrically, \((x_1, 0)\) is the intersection of the x-axis and the tangent of the graph of \(f\) at \((x_0, f(x_0))\).<br  />
 In other words, the improved guess is the unique root of the linear approximation at the initial point.<br  />
 The process is repeated as,<br  />
  </p><p class="formulaDsp">
\begin{equation}
      \large
      x_{n+1} = x_{n} - \frac {f(x_{n})}{f&#39;(x_{n})} ~,
  \end{equation}
</p>
<p> until a sufficiently precise value is reached.<br  />
 The Newton method can also be extended to complex functions and to systems of equations.<br  />
</p>
<p ><b>The Convergence of the Newton Algorithm</b><br  />
</p>
<p >The Newton method will usually converge, provided the initial guess is <em>close enough</em> to the unknown root of the function and \(f\prime(x_0) \neq 0\).<br  />
 Furthermore, for a root of multiplicity \(1\), the convergence is at least quadratic in a neighborhood of the root.<br  />
 This intuitively means that the number of correct digits roughly doubles in every step.<br  />
 More details can be found in the analysis section below.</p>
<p ><b>Practical Considerations for the Newton Algorithm</b><br  />
</p>
<p >The Newton method is a powerful technique.<br  />
 Convergence is generally quadratic.<br  />
 However, there are some difficulties associated with the method.<br  />
 </p><ul>
<li>
<b>The Newton method requires the function derivative.</b><br  />
 The Newton method requires that the derivative can be calculated directly.<br  />
 An analytical expression for the derivative may not be easily obtainable or could be expensive to evaluate.<br  />
 In these situations, it may be appropriate to approximate the derivative by using the slope of a line through two nearby points on the function.<br  />
 However, numerical approximation of the derivative degrade the convergence rate and performance to the Secant method which is slower than the Newton method.<br  />
 </li>
<li>
<b>The Newton method can fail to converge to the root.</b><br  />
 The proof quadratic convergence of the Newton method requires certain assumptions that may not always hold.<br  />
 One should therefore review the assumptions before using the Newton method.<br  />
 For situations where the method fails to converge, it is because the assumptions made in the proof convergence are not met.<br  />
 </li>
<li>
<b>The Newton method can overshoot.</b><br  />
 If the first derivative is not well behaved in the neighborhood of a particular root, the method may overshoot, and diverge from that root.<br  />
 An example of a function with one root, for which the derivative is not well behaved in the neighborhood of the root, is  <p class="formulaDsp">
\begin{equation}
                  \large
                  f(x) = |x|^{a} ~, \quad 0 &lt; a &lt; \frac{1}{2} ~,
              \end{equation}
</p>
 for which the root will be overshot and the sequence of \(x\) will diverge.<br  />
 For \(a = 1/2\), the root will still be overshot, but the sequence will oscillate between two values.<br  />
 For \(1/2 &lt; a &lt; 1\), the root will still be overshot but the sequence will converge.<br  />
 For \(a \geq 1\) the root will not be overshot at all.<br  />
 In some cases, the Newton method can be stabilized by using successive over-relaxation.<br  />
 </li>
<li>
<b>The Newton method can prematurely terminate upon encountering stationary points of the function.</b><br  />
 If a stationary point of the function is encountered, the derivative is zero and the method will terminate due to division by zero.<br  />
 </li>
<li>
<b>The Newton method can fail due to poor initial starting point for the search.</b><br  />
 A large error in the initial estimate can contribute to non-convergence of the algorithm.<br  />
 To overcome this problem one can linearize the function that is being optimized.<br  />
 Good initial estimates lie close to the final globally optimal parameter estimate.<br  />
 </li>
</ul>
<dl class="section remark"><dt>Remarks</dt><dd><b>The procedures of this module use a hybrid Newton-Bisection method to resolve the difficulties mentioned above.</b><br  />
 See <a href="https://en.wikipedia.org/wiki/Newton%27s_method#Failure_analysis">this article</a> for an exhaustive discussion of the failures and remedies.<br  />
</dd>
<dd>
The finite precision of computers can cause problems for convergence of the Newton method.<br  />
 As such, the implementations of the method frequently include convergence tests or limits to the number of iterations.<br  />
 Although \(f\) is continuous, the finite precision of computer can preclude a function value ever being zero.<br  />
 Additionally, the difference between the search interval limits cannot be less than the floating point precision of the computer.<br  />
</dd></dl>
<h2><a class="anchor" id="autotoc_md49"></a>
The Halley method</h2>
<p >In numerical analysis, the Halley method is a root-finding algorithm used for functions of one real variable <b>with a continuous second derivative</b>.<br  />
 It is named after its inventor <a href="https://en.wikipedia.org/wiki/Edmond_Halley">Edmond Halley</a>.<br  />
 The algorithm is second in the class of Householder methods, after Newton method.<br  />
 Like the latter, it iteratively produces a sequence of approximations to the root.<br  />
 The <b>rate of convergence</b> to the root is <b>cubic</b>.<br  />
 The Halley method exactly finds the roots of a linear-over-linear Padé approximation to the function, in contrast to the Newton method or the Secant method which approximate the function linearly, or the Muller method which approximates the function quadratically.<br  />
</p>
<p ><b>The Halley Algorithm</b><br  />
</p>
<p >The Halley method solves the nonlinear equation \(f(x) = 0\).<br  />
 In this case, the function \(f\) has to be a function of one real variable.<br  />
 The method consists of a sequence of iterations:<br  />
  </p><p class="formulaDsp">
\begin{equation}
      x_{{n+1}} = x_{n} - \frac{2f(x_{n})f&#39;(x_{n})}{2{[f&#39;(x_{n})]}^{2}-f(x_{n})f&#39;&#39;(x_{n})} ~,
  \end{equation}
</p>
<p> beginning with an initial guess \(x_0\).<br  />
</p>
<p ><b>The Convergence of the Halley Algorithm</b><br  />
</p>
<p >The Halley method converges <b>cubically</b> to the function root.<br  />
 That is, each iteration triples the number of significant digits in the final root.<br  />
 In comparison, two steps of Newton-Raphson quadruple the number of digits in the final root.<br  />
</p>
<p ><b>Practical Considerations for the Halley Algorithm</b><br  />
</p>
<p >The use of the Halley method is sensible only when it is easy to calculate the second derivative of the target function.<br  />
 The basin of convergence of the Halley method is not guaranteed to be larger than that of the Newton method.<br  />
 This means that the Halley method does not necessarily yield faster convergence rates as evidenced by the examples of the generic interfaces of this module.<br  />
 he current implementation of the Halley method in this module resolves over-compensations by the second derivative (leading to wrong search directions) by reverting the search method to a Newton-Raphson step.<br  />
 If the method sends the search out of the initial user-specified bracket of the root, then the algorithm falls back to the bisection method to correct the search.<br  />
</p>
<h2><a class="anchor" id="autotoc_md50"></a>
The Schroder method</h2>
<p >Similar to the Halley method, the Schroder method solves the nonlinear equation \(f(x) = 0\) using the second derivative.<br  />
 However, unlike the Newton and the Halley methods, the Schroder method is known to work well in the presence of multiple roots.<br  />
 The method consists of a sequence of iterations:<br  />
  </p><p class="formulaDsp">
\begin{equation}
      x_{{n+1}} = x_{n} - \frac{f(x_n)}{f&#39;(x_n)} - \frac{[f(x_n)]^2 f&#39;&#39;(x_n)}{2[f&#39;(x_n)]^3} ~,
  \end{equation}
</p>
<p> beginning with an initial guess \(x_0\).<br  />
 See <a href="http://drum.lib.umd.edu/handle/1903/577">Stewart, 1993, G. W. On Infinitely Many Algorithms for Solving Equations</a> for the English translation of the original paper of Schroder and the derivation of the above equation on page 13.<br  />
</p>
<h1><a class="anchor" id="autotoc_md51"></a>
Hybrid methods</h1>
<h2><a class="anchor" id="autotoc_md52"></a>
The Brent method</h2>
<p >The Brent method is a <b>hybrid</b> root-finding algorithm combining<br  />
 </p><ul>
<li>
the <b>Bisection method</b>,<br  />
 </li>
<li>
the <b>Secant method</b>, and<br  />
 </li>
<li>
the <b>inverse quadratic interpolation</b>.<br  />
 </li>
</ul>
<p>It has the <b>reliability of the Bisection method</b> but potentially as fast as some of the less-reliable methods above.<br  />
 The algorithm tries to use the potentially <b>fast-converging</b> Secant method or inverse quadratic interpolation if possible.<br  />
 If necessary, it falls back to the more robust Bisection method.<br  />
 The Brent method is due to <a href="https://en.wikipedia.org/wiki/Richard_P._Brent">Richard Brent</a> and builds on an earlier algorithm by <a href="https://en.wikipedia.org/wiki/Theodorus_Dekker">Theodorus Dekker</a>.<br  />
</p>
<p >The Quadratic method employed in the Brent method works well only when the function behaves smoothly.<br  />
 However, they run the serious risk of giving very bad estimates of the root or causing machine failure by an inappropriate division by a very small number.<br  />
 The Brent method guards against this problem by maintaining the search brackets on the root and checking where the interpolation would land before carrying out divisions.<br  />
 When the corrections due to the Quadratic method would not land within the search bounds, or when the bounds are not collapsing rapidly enough, the algorithm takes a bisection step.<br  />
 Thus, <b>the Brent method combines the sureness of the Bisection method with the speed of a higher-order method when appropriate</b>.<br  />
</p>
<dl class="section remark"><dt>Remarks</dt><dd>The brent algorithm implemented in this module is a reimplementation of the original <a href="https://netlib.org/go/zeroin.f">FORTRAN77 Brent method from the NetLib library</a> combined with improvements inspired by the <a href="http://numerical.recipes/">Numerical Recipes in Fortran, Press et al. 1991</a>.<br  />
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The algorithm is also known as the <b>Van Wijngaarden–Dekker–Brent root-finding method</b> or the <b>Brent–Dekker root-finding method</b>.<br  />
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The finite precision of computers can cause problems for convergence of the Brent method.<br  />
 As such, the implementations of the method frequently include convergence tests or limits to the number of iterations.<br  />
 Although \(f\) is continuous, the finite precision of computer can preclude a function value ever being zero.<br  />
 Additionally, the difference between the search interval limits cannot be less than the floating point precision of the computer.<br  />
</dd></dl>
<h2><a class="anchor" id="autotoc_md53"></a>
The Ridders method</h2>
<p >The Ridders method is a root-finding algorithm based on the False-Position method and the use of an exponential function to successively approximate a root of a continuous function.<br  />
 The method is due to C. Ridders.<br  />
</p>
<p ><b>The Ridders Algorithm</b><br  />
</p>
<p >Given two values of the independent variable, \(x_0 &lt; \mathrm{root} &lt; x_2\), the method begins by evaluating the function at the midpoint \(x_1 = (x_0 + x_2) / 2\).<br  />
 One then finds the unique exponential function \(e^{ax}\) such that the function \(h(x) = f(x) \exp(ax)\) satisfies \(h(x_1) = (h(x_0) + h(x_2)) / 2\).<br  />
 Specifically, the parameter \(a\) is determined by,<br  />
  </p><p class="formulaDsp">
\begin{equation}
      \large
      \exp\big(a(x_1 - x_0)\big) = \frac{f(x_1) - \mathrm{sign}\big(f(x_0)\big){\sqrt{f(x_1)^2 - f(x_0) f(x_2)}}}{f(x_2)} ~.
  \end{equation}
</p>
<p> The False-Position method is then applied to the points \((x_0, h(x_0))\) and \((x_2, h(x_2))\), leading to a new value \(x_3\) between \(x_0\) and \(x_2\),  </p><p class="formulaDsp">
\begin{equation}
      \large
      x_3 = x_1 + (x_1 - x_0) \frac{\mathrm{sign}\big(f(x_0)\big) f(x_1)} {\sqrt{f(x_1)^2 - f(x_0) f(x_2)}} ~,
  \end{equation}
</p>
<p> which will be used as one of the two bracketing values in the next step of the iteration.<br  />
 The other bracketing value is taken to be \(x_1\) if \(f(x_1) f(x_3) &lt; 0\) (well-behaved case), or otherwise whichever of \(x_0\) and \(x_2\) has function value of opposite sign to \(f(x_3)\).<br  />
 The procedure terminates when the desired accuracy is achieved.<br  />
</p>
<p ><b>The Convergence of the Ridders Algorithm</b><br  />
</p>
<p >The Ridders method is simpler than the Muller method or the Brent method but with similar performance.<br  />
 The algorithm converges quadratically when the function is well-behaved.<br  />
 This implies that the number of additional significant digits found at each step approximately doubles.<br  />
 However, since the function has to be evaluated twice per iteration, the overall order of convergence of the method is \(\sqrt{2}\).<br  />
 The root remains bracketed and the length of the bracketing interval at least halves on each iteration, even the function is not well-behaved.<br  />
 In all circumstances, the convergence is guaranteed.</p>
<dl class="section remark"><dt>Remarks</dt><dd>The finite precision of computers can cause problems for convergence of the Ridders method.<br  />
 As such, the implementations of the method frequently include convergence tests or limits to the number of iterations.<br  />
 Although \(f\) is continuous, the finite precision of computer can preclude a function value ever being zero.<br  />
 Additionally, the difference between the search interval limits cannot be less than the floating point precision of the computer.<br  />
</dd></dl>
<h2><a class="anchor" id="autotoc_md54"></a>
The TOMS748 method</h2>
<p >The <a href="https://na.math.kit.edu/alefeld/download/1995_Algorithm_748_Enclosing_Zeros_of_Continuous_Functions.pdf">TOMS748 algorithm</a> is a hybrid root-finding algorithm introduced in,<br  />
 </p><ul>
<li>
Alefeld, G. E., Potra, F. A., Shi, Yixun (1995). "Algorithm 748: Enclosing Zeros of Continuous Functions". ACM Transactions on Mathematical Software. 21 (3): 327–344. doi:10.1145/210089.210111 </li>
</ul>
<p>that uses a mixture of cubic, quadratic and linear (secant) interpolation to locate the root of a function.<br  />
 While there is widespread claims of the superior performance of this algorithm compared to the Brent method, there are <a href="https://www.nongnu.org/lmi/toms_748.html">counter arguments</a> for such benchmarks.<br  />
</p>
<h1><a class="anchor" id="autotoc_md55"></a>
The optimal root-finding method</h1>
<p >The best root-finding algorithm depends on the problem being solved:<br  />
 </p><ol>
<li>
The Brent method is the recommended <b>algorithm of choice</b> for general one-dimensional root-finding problems <b>without</b> knowledge of function derivative (gradient).<br  />
 </li>
<li>
The <a class="el" href="namespacepm__mathRoot.html">Newton-Raphson method</a> is the recommended <b>algorithm of choice</b> for general one-dimensional root-finding problems <b>with</b> knowledge of function derivative (gradient).<br  />
 </li>
</ol>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacepm__arraySearch.html">pm_arraySearch</a><br  />
 <a class="el" href="interfacepm__polynomial_1_1getPolyRoot.html">getPolyRoot</a><br  />
 <a class="el" href="interfacepm__polynomial_1_1setPolyRoot.html">setPolyRoot</a><br  />
 <a href="https://en.wikipedia.org/wiki/Regula_falsi">Regula Falsi</a><br  />
 <a href="https://en.wikipedia.org/wiki/Secant_method">The Secant Algorithm</a><br  />
 <a href="https://en.wikipedia.org/wiki/Bisection_method">The Bisection Algorithm</a><br  />
 <a href="https://en.wikipedia.org/wiki/Root-finding_algorithms">Root-Finding Algorithms</a><br  />
 <a href="https://en.wikipedia.org/wiki/Root-finding_algorithms">Root-Finding Algorithms</a><br  />
 <a href="https://mathworld.wolfram.com/MethodofFalsePosition.html#:~:text=An%20algorithm%20for%20finding%20roots,1992">Method of False Position</a><br  />
 Brent, Richard P., 1971, <em>An algorithm with guaranteed convergence for finding a zero of a function</em>, The computer journal, 14, 4, 422-425<br  />
 Newton, Richard P., 1971, <em>An algorithm with guaranteed convergence for finding a zero of a function</em>, The computer journal, 14, 4, 422-425<br  />
 Ridders, C. F. J. <em>A New Algorithm for Computing a Single Root of a Real Continuous Function.</em> IEEE Trans. Circuits Systems 26, 979-980, 1979<br  />
 Schröder, E. "Über unendlich viele Algorithmen zur Auflösung der Gleichungen." Math. Ann. 2, 317-365, 1870<br  />
 <a href="https://github.com/jacobwilliams/roots-fortran">RootsFortran</a>: An extensive Fortran library for root-finding by <a href="https://github.com/jacobwilliams">Jacob Williams</a><br  />
 Numerical Recipes in Fortran, Press et al. 1992<br  />
 <a href="https://netlib.org/slatec/src/">SLATEC cdzro.f</a><br  />
 <a href="https://www.boost.org/doc/libs/1_82_0/libs/math/doc/html/root_finding.html">Boost library</a><br  />
</dd></dl>
<dl class="test"><dt><b><a class="el" href="test.html#_test000613">Test:</a></b></dt><dd><a class="el" href="namespacetest__pm__mathRoot.html">test_pm_mathRoot</a></dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000306">Todo:</a></b></dt><dd><span class="pmed">Normal Priority</span>: The <a href="https://en.wikipedia.org/wiki/Muller%27s_method">Muller method</a> of root-finding should be implemented.<br  />
</dd></dl>
<p ><br  />
<a class="anchor" id="finmain"></a><b>Final Remarks</b> <a href="#finmain">⛓</a> </p><hr  />
<p> If you believe this algorithm or its documentation can be improved, <b>we appreciate your contribution and help</b> <a href="https://github.com/cdslaborg/paramonte/tree/master/src/fortran/main/pm_mathRoot.F90#L447 " target="_blank"><b>to edit this page's documentation and source file on GitHub</b></a>.<br  />
 For details on the naming abbreviations, see <a class="el" href="index.html#ParaMonteLangAbbreviationGuidlines">this page</a>.<br  />
 For details on the naming conventions, see <a class="el" href="index.html#ParaMonteLangNamingConventions">this page</a>.<br  />
 This software is distributed under the <a href="https://github.com/cdslaborg/paramonte#license" target="_blank">MIT license</a> <b>with additional terms outlined below.</b><br  />
</p><ol>
<li>
If you use any parts or concepts from this library to any extent, <b>you must acknowledge the usage by citing the relevant</b> <a href="https://www.cdslab.org/paramonte/generic/latest/overview/preface/#how-to-acknowledge-the-use-of-the-paramonte-library-in-your-work" target="_blank"><b>publications of the ParaMonte library</b></a>.<br  />
</li>
<li>
If you regenerate any parts/ideas from this library in a programming environment other than those currently supported by this ParaMonte library, <b>you must also ask the end users to</b> <a href="https://www.cdslab.org/paramonte/generic/latest/overview/preface/#how-to-acknowledge-the-use-of-the-paramonte-library-in-your-work" target="_blank"><b>cite this original ParaMonte library</b></a>.<br  />
</li>
</ol>
<dl class="section copyright"><dt>Copyright</dt><dd><a href="https://www.cdslab.org" target="_blank">Computational Data Science Lab</a></dd></dl>
<dl class="authors"><dt><b><a class="el" href="authors.html#_authors000813">Author:</a></b></dt><dd><a href="https://www.github.com/shahmoradi" target="_blank">Amir Shahmoradi</a>, Oct 16, 2009, 11:14 AM, Michigan </dd></dl>
</div><h2 class="groupheader">Variable Documentation</h2>
<a id="a5504dde0cb89575fd6f0882739a0d7b7" name="a5504dde0cb89575fd6f0882739a0d7b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5504dde0cb89575fd6f0882739a0d7b7">&#9670;&nbsp;</a></span>bisection</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structpm__mathRoot_1_1bisection__type.html">bisection_type</a>), parameter pm_mathRoot::bisection = <a class="el" href="structpm__mathRoot_1_1bisection__type.html">bisection_type</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a scalar <code>parameter</code> object of type <a class="el" href="structpm__mathRoot_1_1bisection__type.html">bisection_type</a> that is exclusively used to signify the use of Bisection method of root-finding within an interface of a procedure of the ParaMonte library.<br  />
 </p>
<p >See the root-finding section in the documentation of <a class="el" href="namespacepm__mathRoot.html">pm_mathRoot</a> for more details about this root-finding method.<br  />
 For example usage, see the documentation of the target procedure requiring this object.<br  />
</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacepm__mathRoot.html#a3409e5000efdde261d2f3265678d0436">brent</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a7e707e2dada15fddfbd434f621f6b1ef">false</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#aeada6d7662ab9da56ae68e165f35be3b">secant</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#add19d3b40dedb3c60958cb830fdcd2cc">halley</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a4ab1ab19049b29b25610aef4eaedfd3e">newton</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a3e803f26dcf937fbb6158b0dbbd94960">ridders</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a471263361906d447d3ec06b1bf3eef0b">toms748</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#aea044c5c7944004b6c2f9c050e3cf810">schroder</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a5504dde0cb89575fd6f0882739a0d7b7">bisection</a><br  />
 <a class="el" href="structpm__mathRoot_1_1brent__type.html">brent_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1false__type.html">false_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1secant__type.html">secant_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1halley__type.html">halley_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1newton__type.html">newton_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1ridders__type.html">ridders_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1toms748__type.html">toms748_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1schroder__type.html">schroder_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1bisection__type.html">bisection_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1iteration__type.html">iteration_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1bracket__type.html">bracket_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1hybrid__type.html">hybrid_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1method__type.html">method_type</a><br  />
</dd></dl>
<p><br  />
<a class="anchor" id="finmain-bisection"></a><b>Final Remarks</b> <a href="#finmain-bisection">⛓</a> </p><hr  />
<p> If you believe this algorithm or its documentation can be improved, <b>we appreciate your contribution and help</b> <a href="https://github.com/cdslaborg/paramonte/tree/master/src/fortran/main/pm_mathRoot.F90#L1385 " target="_blank"><b>to edit this page's documentation and source file on GitHub</b></a>.<br  />
 For details on the naming abbreviations, see <a class="el" href="index.html#ParaMonteLangAbbreviationGuidlines">this page</a>.<br  />
 For details on the naming conventions, see <a class="el" href="index.html#ParaMonteLangNamingConventions">this page</a>.<br  />
 This software is distributed under the <a href="https://github.com/cdslaborg/paramonte#license" target="_blank">MIT license</a> <b>with additional terms outlined below.</b><br  />
</p><ol>
<li>
If you use any parts or concepts from this library to any extent, <b>you must acknowledge the usage by citing the relevant</b> <a href="https://www.cdslab.org/paramonte/generic/latest/overview/preface/#how-to-acknowledge-the-use-of-the-paramonte-library-in-your-work" target="_blank"><b>publications of the ParaMonte library</b></a>.<br  />
</li>
<li>
If you regenerate any parts/ideas from this library in a programming environment other than those currently supported by this ParaMonte library, <b>you must also ask the end users to</b> <a href="https://www.cdslab.org/paramonte/generic/latest/overview/preface/#how-to-acknowledge-the-use-of-the-paramonte-library-in-your-work" target="_blank"><b>cite this original ParaMonte library</b></a>.<br  />
</li>
</ol>
<dl class="section copyright"><dt>Copyright</dt><dd><a href="https://www.cdslab.org" target="_blank">Computational Data Science Lab</a></dd></dl>
<dl class="authors"><dt><b><a class="el" href="authors.html#_authors000835">Author:</a></b></dt><dd><a href="https://www.github.com/shahmoradi" target="_blank">Amir Shahmoradi</a>, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin </dd></dl>

<p class="definition">Definition at line <a class="el" href="pm__mathRoot_8F90_source.html#l01389">1389</a> of file <a class="el" href="pm__mathRoot_8F90_source.html">pm_mathRoot.F90</a>.</p>

</div>
</div>
<a id="a3409e5000efdde261d2f3265678d0436" name="a3409e5000efdde261d2f3265678d0436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3409e5000efdde261d2f3265678d0436">&#9670;&nbsp;</a></span>brent</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structpm__mathRoot_1_1brent__type.html">brent_type</a>), parameter pm_mathRoot::brent = <a class="el" href="structpm__mathRoot_1_1brent__type.html">brent_type</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a scalar <code>parameter</code> object of type <a class="el" href="structpm__mathRoot_1_1brent__type.html">brent_type</a> that is exclusively used to signify the use of Brent method of root-finding within an interface of a procedure of the ParaMonte library.<br  />
 </p>
<p >See the root-finding section in the documentation of <a class="el" href="namespacepm__mathRoot.html">pm_mathRoot</a> for more details about this root-finding method.<br  />
 For example usage, see the documentation of the target procedure requiring this object.<br  />
</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacepm__mathRoot.html#a3409e5000efdde261d2f3265678d0436">brent</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a7e707e2dada15fddfbd434f621f6b1ef">false</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#aeada6d7662ab9da56ae68e165f35be3b">secant</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#add19d3b40dedb3c60958cb830fdcd2cc">halley</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a4ab1ab19049b29b25610aef4eaedfd3e">newton</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a3e803f26dcf937fbb6158b0dbbd94960">ridders</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a471263361906d447d3ec06b1bf3eef0b">toms748</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#aea044c5c7944004b6c2f9c050e3cf810">schroder</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a5504dde0cb89575fd6f0882739a0d7b7">bisection</a><br  />
 <a class="el" href="structpm__mathRoot_1_1brent__type.html">brent_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1false__type.html">false_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1secant__type.html">secant_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1halley__type.html">halley_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1newton__type.html">newton_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1ridders__type.html">ridders_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1toms748__type.html">toms748_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1schroder__type.html">schroder_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1bisection__type.html">bisection_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1iteration__type.html">iteration_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1bracket__type.html">bracket_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1hybrid__type.html">hybrid_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1method__type.html">method_type</a><br  />
</dd></dl>
<p><br  />
<a class="anchor" id="finmain-brent"></a><b>Final Remarks</b> <a href="#finmain-brent">⛓</a> </p><hr  />
<p> If you believe this algorithm or its documentation can be improved, <b>we appreciate your contribution and help</b> <a href="https://github.com/cdslaborg/paramonte/tree/master/src/fortran/main/pm_mathRoot.F90#L705 " target="_blank"><b>to edit this page's documentation and source file on GitHub</b></a>.<br  />
 For details on the naming abbreviations, see <a class="el" href="index.html#ParaMonteLangAbbreviationGuidlines">this page</a>.<br  />
 For details on the naming conventions, see <a class="el" href="index.html#ParaMonteLangNamingConventions">this page</a>.<br  />
 This software is distributed under the <a href="https://github.com/cdslaborg/paramonte#license" target="_blank">MIT license</a> <b>with additional terms outlined below.</b><br  />
</p><ol>
<li>
If you use any parts or concepts from this library to any extent, <b>you must acknowledge the usage by citing the relevant</b> <a href="https://www.cdslab.org/paramonte/generic/latest/overview/preface/#how-to-acknowledge-the-use-of-the-paramonte-library-in-your-work" target="_blank"><b>publications of the ParaMonte library</b></a>.<br  />
</li>
<li>
If you regenerate any parts/ideas from this library in a programming environment other than those currently supported by this ParaMonte library, <b>you must also ask the end users to</b> <a href="https://www.cdslab.org/paramonte/generic/latest/overview/preface/#how-to-acknowledge-the-use-of-the-paramonte-library-in-your-work" target="_blank"><b>cite this original ParaMonte library</b></a>.<br  />
</li>
</ol>
<dl class="section copyright"><dt>Copyright</dt><dd><a href="https://www.cdslab.org" target="_blank">Computational Data Science Lab</a></dd></dl>
<dl class="authors"><dt><b><a class="el" href="authors.html#_authors000819">Author:</a></b></dt><dd><a href="https://www.github.com/shahmoradi" target="_blank">Amir Shahmoradi</a>, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin </dd></dl>

<p class="definition">Definition at line <a class="el" href="pm__mathRoot_8F90_source.html#l00709">709</a> of file <a class="el" href="pm__mathRoot_8F90_source.html">pm_mathRoot.F90</a>.</p>

</div>
</div>
<a id="a7e707e2dada15fddfbd434f621f6b1ef" name="a7e707e2dada15fddfbd434f621f6b1ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e707e2dada15fddfbd434f621f6b1ef">&#9670;&nbsp;</a></span>false</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structpm__mathRoot_1_1false__type.html">false_type</a>), parameter pm_mathRoot::false = <a class="el" href="structpm__mathRoot_1_1false__type.html">false_type</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a scalar <code>parameter</code> object of type <a class="el" href="structpm__mathRoot_1_1false__type.html">false_type</a> that is exclusively used to signify the use of False-Position method of root-finding within an interface of a procedure of the ParaMonte library.<br  />
 </p>
<p >See the root-finding section in the documentation of <a class="el" href="namespacepm__mathRoot.html">pm_mathRoot</a> for more details about this root-finding method.<br  />
 For example usage, see the documentation of the target procedure requiring this object.<br  />
</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacepm__mathRoot.html#a3409e5000efdde261d2f3265678d0436">brent</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a7e707e2dada15fddfbd434f621f6b1ef">false</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#aeada6d7662ab9da56ae68e165f35be3b">secant</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#add19d3b40dedb3c60958cb830fdcd2cc">halley</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a4ab1ab19049b29b25610aef4eaedfd3e">newton</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a3e803f26dcf937fbb6158b0dbbd94960">ridders</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a471263361906d447d3ec06b1bf3eef0b">toms748</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#aea044c5c7944004b6c2f9c050e3cf810">schroder</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a5504dde0cb89575fd6f0882739a0d7b7">bisection</a><br  />
 <a class="el" href="structpm__mathRoot_1_1brent__type.html">brent_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1false__type.html">false_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1secant__type.html">secant_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1halley__type.html">halley_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1newton__type.html">newton_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1ridders__type.html">ridders_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1toms748__type.html">toms748_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1schroder__type.html">schroder_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1bisection__type.html">bisection_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1iteration__type.html">iteration_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1bracket__type.html">bracket_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1hybrid__type.html">hybrid_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1method__type.html">method_type</a><br  />
</dd></dl>
<p><br  />
<a class="anchor" id="finmain-false"></a><b>Final Remarks</b> <a href="#finmain-false">⛓</a> </p><hr  />
<p> If you believe this algorithm or its documentation can be improved, <b>we appreciate your contribution and help</b> <a href="https://github.com/cdslaborg/paramonte/tree/master/src/fortran/main/pm_mathRoot.F90#L875 " target="_blank"><b>to edit this page's documentation and source file on GitHub</b></a>.<br  />
 For details on the naming abbreviations, see <a class="el" href="index.html#ParaMonteLangAbbreviationGuidlines">this page</a>.<br  />
 For details on the naming conventions, see <a class="el" href="index.html#ParaMonteLangNamingConventions">this page</a>.<br  />
 This software is distributed under the <a href="https://github.com/cdslaborg/paramonte#license" target="_blank">MIT license</a> <b>with additional terms outlined below.</b><br  />
</p><ol>
<li>
If you use any parts or concepts from this library to any extent, <b>you must acknowledge the usage by citing the relevant</b> <a href="https://www.cdslab.org/paramonte/generic/latest/overview/preface/#how-to-acknowledge-the-use-of-the-paramonte-library-in-your-work" target="_blank"><b>publications of the ParaMonte library</b></a>.<br  />
</li>
<li>
If you regenerate any parts/ideas from this library in a programming environment other than those currently supported by this ParaMonte library, <b>you must also ask the end users to</b> <a href="https://www.cdslab.org/paramonte/generic/latest/overview/preface/#how-to-acknowledge-the-use-of-the-paramonte-library-in-your-work" target="_blank"><b>cite this original ParaMonte library</b></a>.<br  />
</li>
</ol>
<dl class="section copyright"><dt>Copyright</dt><dd><a href="https://www.cdslab.org" target="_blank">Computational Data Science Lab</a></dd></dl>
<dl class="authors"><dt><b><a class="el" href="authors.html#_authors000823">Author:</a></b></dt><dd><a href="https://www.github.com/shahmoradi" target="_blank">Amir Shahmoradi</a>, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin </dd></dl>

<p class="definition">Definition at line <a class="el" href="pm__mathRoot_8F90_source.html#l00879">879</a> of file <a class="el" href="pm__mathRoot_8F90_source.html">pm_mathRoot.F90</a>.</p>

</div>
</div>
<a id="add19d3b40dedb3c60958cb830fdcd2cc" name="add19d3b40dedb3c60958cb830fdcd2cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add19d3b40dedb3c60958cb830fdcd2cc">&#9670;&nbsp;</a></span>halley</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structpm__mathRoot_1_1halley__type.html">halley_type</a>), parameter pm_mathRoot::halley = <a class="el" href="structpm__mathRoot_1_1halley__type.html">halley_type</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a scalar <code>parameter</code> object of type <a class="el" href="structpm__mathRoot_1_1halley__type.html">halley_type</a> that is exclusively used to signify the use of Halley method of root-finding within an interface of a procedure of the ParaMonte library.<br  />
 </p>
<p >See the root-finding section in the documentation of <a class="el" href="namespacepm__mathRoot.html">pm_mathRoot</a> for more details about this root-finding method.<br  />
 For example usage, see the documentation of the target procedure requiring this object.<br  />
</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacepm__mathRoot.html#a3409e5000efdde261d2f3265678d0436">brent</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a7e707e2dada15fddfbd434f621f6b1ef">false</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#aeada6d7662ab9da56ae68e165f35be3b">secant</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#add19d3b40dedb3c60958cb830fdcd2cc">halley</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a4ab1ab19049b29b25610aef4eaedfd3e">newton</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a3e803f26dcf937fbb6158b0dbbd94960">ridders</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a471263361906d447d3ec06b1bf3eef0b">toms748</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#aea044c5c7944004b6c2f9c050e3cf810">schroder</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a5504dde0cb89575fd6f0882739a0d7b7">bisection</a><br  />
 <a class="el" href="structpm__mathRoot_1_1brent__type.html">brent_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1false__type.html">false_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1secant__type.html">secant_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1halley__type.html">halley_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1newton__type.html">newton_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1ridders__type.html">ridders_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1toms748__type.html">toms748_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1schroder__type.html">schroder_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1bisection__type.html">bisection_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1iteration__type.html">iteration_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1bracket__type.html">bracket_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1hybrid__type.html">hybrid_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1method__type.html">method_type</a><br  />
</dd></dl>
<p><br  />
<a class="anchor" id="finmain-halley"></a><b>Final Remarks</b> <a href="#finmain-halley">⛓</a> </p><hr  />
<p> If you believe this algorithm or its documentation can be improved, <b>we appreciate your contribution and help</b> <a href="https://github.com/cdslaborg/paramonte/tree/master/src/fortran/main/pm_mathRoot.F90#L1130 " target="_blank"><b>to edit this page's documentation and source file on GitHub</b></a>.<br  />
 For details on the naming abbreviations, see <a class="el" href="index.html#ParaMonteLangAbbreviationGuidlines">this page</a>.<br  />
 For details on the naming conventions, see <a class="el" href="index.html#ParaMonteLangNamingConventions">this page</a>.<br  />
 This software is distributed under the <a href="https://github.com/cdslaborg/paramonte#license" target="_blank">MIT license</a> <b>with additional terms outlined below.</b><br  />
</p><ol>
<li>
If you use any parts or concepts from this library to any extent, <b>you must acknowledge the usage by citing the relevant</b> <a href="https://www.cdslab.org/paramonte/generic/latest/overview/preface/#how-to-acknowledge-the-use-of-the-paramonte-library-in-your-work" target="_blank"><b>publications of the ParaMonte library</b></a>.<br  />
</li>
<li>
If you regenerate any parts/ideas from this library in a programming environment other than those currently supported by this ParaMonte library, <b>you must also ask the end users to</b> <a href="https://www.cdslab.org/paramonte/generic/latest/overview/preface/#how-to-acknowledge-the-use-of-the-paramonte-library-in-your-work" target="_blank"><b>cite this original ParaMonte library</b></a>.<br  />
</li>
</ol>
<dl class="section copyright"><dt>Copyright</dt><dd><a href="https://www.cdslab.org" target="_blank">Computational Data Science Lab</a></dd></dl>
<dl class="authors"><dt><b><a class="el" href="authors.html#_authors000829">Author:</a></b></dt><dd><a href="https://www.github.com/shahmoradi" target="_blank">Amir Shahmoradi</a>, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin </dd></dl>

<p class="definition">Definition at line <a class="el" href="pm__mathRoot_8F90_source.html#l01134">1134</a> of file <a class="el" href="pm__mathRoot_8F90_source.html">pm_mathRoot.F90</a>.</p>

</div>
</div>
<a id="af4b747491d87135fb50b95df1746e856" name="af4b747491d87135fb50b95df1746e856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4b747491d87135fb50b95df1746e856">&#9670;&nbsp;</a></span>MODULE_NAME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">character(*, SK), parameter pm_mathRoot::MODULE_NAME = &quot;@pm_mathRoot&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="pm__mathRoot_8F90_source.html#l00460">460</a> of file <a class="el" href="pm__mathRoot_8F90_source.html">pm_mathRoot.F90</a>.</p>

</div>
</div>
<a id="a4ab1ab19049b29b25610aef4eaedfd3e" name="a4ab1ab19049b29b25610aef4eaedfd3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ab1ab19049b29b25610aef4eaedfd3e">&#9670;&nbsp;</a></span>newton</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structpm__mathRoot_1_1newton__type.html">newton_type</a>), parameter pm_mathRoot::newton = <a class="el" href="structpm__mathRoot_1_1newton__type.html">newton_type</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a scalar <code>parameter</code> object of type <a class="el" href="structpm__mathRoot_1_1newton__type.html">newton_type</a> that is exclusively used to signify the use of Newton method of root-finding within an interface of a procedure of the ParaMonte library.<br  />
 </p>
<p >See the root-finding section in the documentation of <a class="el" href="namespacepm__mathRoot.html">pm_mathRoot</a> for more details about this root-finding method.<br  />
 For example usage, see the documentation of the target procedure requiring this object.<br  />
</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacepm__mathRoot.html#a3409e5000efdde261d2f3265678d0436">brent</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a7e707e2dada15fddfbd434f621f6b1ef">false</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#aeada6d7662ab9da56ae68e165f35be3b">secant</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#add19d3b40dedb3c60958cb830fdcd2cc">halley</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a4ab1ab19049b29b25610aef4eaedfd3e">newton</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a3e803f26dcf937fbb6158b0dbbd94960">ridders</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a471263361906d447d3ec06b1bf3eef0b">toms748</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#aea044c5c7944004b6c2f9c050e3cf810">schroder</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a5504dde0cb89575fd6f0882739a0d7b7">bisection</a><br  />
 <a class="el" href="structpm__mathRoot_1_1brent__type.html">brent_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1false__type.html">false_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1secant__type.html">secant_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1halley__type.html">halley_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1newton__type.html">newton_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1ridders__type.html">ridders_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1toms748__type.html">toms748_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1schroder__type.html">schroder_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1bisection__type.html">bisection_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1iteration__type.html">iteration_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1bracket__type.html">bracket_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1hybrid__type.html">hybrid_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1method__type.html">method_type</a><br  />
</dd></dl>
<p><br  />
<a class="anchor" id="finmain-newton"></a><b>Final Remarks</b> <a href="#finmain-newton">⛓</a> </p><hr  />
<p> If you believe this algorithm or its documentation can be improved, <b>we appreciate your contribution and help</b> <a href="https://github.com/cdslaborg/paramonte/tree/master/src/fortran/main/pm_mathRoot.F90#L1045 " target="_blank"><b>to edit this page's documentation and source file on GitHub</b></a>.<br  />
 For details on the naming abbreviations, see <a class="el" href="index.html#ParaMonteLangAbbreviationGuidlines">this page</a>.<br  />
 For details on the naming conventions, see <a class="el" href="index.html#ParaMonteLangNamingConventions">this page</a>.<br  />
 This software is distributed under the <a href="https://github.com/cdslaborg/paramonte#license" target="_blank">MIT license</a> <b>with additional terms outlined below.</b><br  />
</p><ol>
<li>
If you use any parts or concepts from this library to any extent, <b>you must acknowledge the usage by citing the relevant</b> <a href="https://www.cdslab.org/paramonte/generic/latest/overview/preface/#how-to-acknowledge-the-use-of-the-paramonte-library-in-your-work" target="_blank"><b>publications of the ParaMonte library</b></a>.<br  />
</li>
<li>
If you regenerate any parts/ideas from this library in a programming environment other than those currently supported by this ParaMonte library, <b>you must also ask the end users to</b> <a href="https://www.cdslab.org/paramonte/generic/latest/overview/preface/#how-to-acknowledge-the-use-of-the-paramonte-library-in-your-work" target="_blank"><b>cite this original ParaMonte library</b></a>.<br  />
</li>
</ol>
<dl class="section copyright"><dt>Copyright</dt><dd><a href="https://www.cdslab.org" target="_blank">Computational Data Science Lab</a></dd></dl>
<dl class="authors"><dt><b><a class="el" href="authors.html#_authors000827">Author:</a></b></dt><dd><a href="https://www.github.com/shahmoradi" target="_blank">Amir Shahmoradi</a>, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin </dd></dl>

<p class="definition">Definition at line <a class="el" href="pm__mathRoot_8F90_source.html#l01049">1049</a> of file <a class="el" href="pm__mathRoot_8F90_source.html">pm_mathRoot.F90</a>.</p>

</div>
</div>
<a id="a3e803f26dcf937fbb6158b0dbbd94960" name="a3e803f26dcf937fbb6158b0dbbd94960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e803f26dcf937fbb6158b0dbbd94960">&#9670;&nbsp;</a></span>ridders</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structpm__mathRoot_1_1ridders__type.html">ridders_type</a>), parameter pm_mathRoot::ridders = <a class="el" href="structpm__mathRoot_1_1ridders__type.html">ridders_type</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a scalar <code>parameter</code> object of type <a class="el" href="structpm__mathRoot_1_1ridders__type.html">ridders_type</a> that is exclusively used to signify the use of Ridders method of root-finding within an interface of a procedure of the ParaMonte library.<br  />
 </p>
<p >See the root-finding section in the documentation of <a class="el" href="namespacepm__mathRoot.html">pm_mathRoot</a> for more details about this root-finding method.<br  />
 For example usage, see the documentation of the target procedure requiring this object.<br  />
</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacepm__mathRoot.html#a3409e5000efdde261d2f3265678d0436">brent</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a7e707e2dada15fddfbd434f621f6b1ef">false</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#aeada6d7662ab9da56ae68e165f35be3b">secant</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#add19d3b40dedb3c60958cb830fdcd2cc">halley</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a4ab1ab19049b29b25610aef4eaedfd3e">newton</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a3e803f26dcf937fbb6158b0dbbd94960">ridders</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a471263361906d447d3ec06b1bf3eef0b">toms748</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#aea044c5c7944004b6c2f9c050e3cf810">schroder</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a5504dde0cb89575fd6f0882739a0d7b7">bisection</a><br  />
 <a class="el" href="structpm__mathRoot_1_1brent__type.html">brent_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1false__type.html">false_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1secant__type.html">secant_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1halley__type.html">halley_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1newton__type.html">newton_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1ridders__type.html">ridders_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1toms748__type.html">toms748_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1schroder__type.html">schroder_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1bisection__type.html">bisection_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1iteration__type.html">iteration_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1bracket__type.html">bracket_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1hybrid__type.html">hybrid_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1method__type.html">method_type</a><br  />
</dd></dl>
<p><br  />
<a class="anchor" id="finmain-ridders"></a><b>Final Remarks</b> <a href="#finmain-ridders">⛓</a> </p><hr  />
<p> If you believe this algorithm or its documentation can be improved, <b>we appreciate your contribution and help</b> <a href="https://github.com/cdslaborg/paramonte/tree/master/src/fortran/main/pm_mathRoot.F90#L1300 " target="_blank"><b>to edit this page's documentation and source file on GitHub</b></a>.<br  />
 For details on the naming abbreviations, see <a class="el" href="index.html#ParaMonteLangAbbreviationGuidlines">this page</a>.<br  />
 For details on the naming conventions, see <a class="el" href="index.html#ParaMonteLangNamingConventions">this page</a>.<br  />
 This software is distributed under the <a href="https://github.com/cdslaborg/paramonte#license" target="_blank">MIT license</a> <b>with additional terms outlined below.</b><br  />
</p><ol>
<li>
If you use any parts or concepts from this library to any extent, <b>you must acknowledge the usage by citing the relevant</b> <a href="https://www.cdslab.org/paramonte/generic/latest/overview/preface/#how-to-acknowledge-the-use-of-the-paramonte-library-in-your-work" target="_blank"><b>publications of the ParaMonte library</b></a>.<br  />
</li>
<li>
If you regenerate any parts/ideas from this library in a programming environment other than those currently supported by this ParaMonte library, <b>you must also ask the end users to</b> <a href="https://www.cdslab.org/paramonte/generic/latest/overview/preface/#how-to-acknowledge-the-use-of-the-paramonte-library-in-your-work" target="_blank"><b>cite this original ParaMonte library</b></a>.<br  />
</li>
</ol>
<dl class="section copyright"><dt>Copyright</dt><dd><a href="https://www.cdslab.org" target="_blank">Computational Data Science Lab</a></dd></dl>
<dl class="authors"><dt><b><a class="el" href="authors.html#_authors000833">Author:</a></b></dt><dd><a href="https://www.github.com/shahmoradi" target="_blank">Amir Shahmoradi</a>, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin </dd></dl>

<p class="definition">Definition at line <a class="el" href="pm__mathRoot_8F90_source.html#l01304">1304</a> of file <a class="el" href="pm__mathRoot_8F90_source.html">pm_mathRoot.F90</a>.</p>

</div>
</div>
<a id="aea044c5c7944004b6c2f9c050e3cf810" name="aea044c5c7944004b6c2f9c050e3cf810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea044c5c7944004b6c2f9c050e3cf810">&#9670;&nbsp;</a></span>schroder</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structpm__mathRoot_1_1schroder__type.html">schroder_type</a>), parameter pm_mathRoot::schroder = <a class="el" href="structpm__mathRoot_1_1schroder__type.html">schroder_type</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a scalar <code>parameter</code> object of type <a class="el" href="structpm__mathRoot_1_1schroder__type.html">schroder_type</a> that is exclusively used to signify the use of Schroder method of root-finding within an interface of a procedure of the ParaMonte library.<br  />
 </p>
<p >See the root-finding section in the documentation of <a class="el" href="namespacepm__mathRoot.html">pm_mathRoot</a> for more details about this root-finding method.<br  />
 For example usage, see the documentation of the target procedure requiring this object.<br  />
</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacepm__mathRoot.html#a3409e5000efdde261d2f3265678d0436">brent</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a7e707e2dada15fddfbd434f621f6b1ef">false</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#aeada6d7662ab9da56ae68e165f35be3b">secant</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#add19d3b40dedb3c60958cb830fdcd2cc">halley</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a4ab1ab19049b29b25610aef4eaedfd3e">newton</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a3e803f26dcf937fbb6158b0dbbd94960">ridders</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a471263361906d447d3ec06b1bf3eef0b">toms748</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#aea044c5c7944004b6c2f9c050e3cf810">schroder</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a5504dde0cb89575fd6f0882739a0d7b7">bisection</a><br  />
 <a class="el" href="structpm__mathRoot_1_1brent__type.html">brent_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1false__type.html">false_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1secant__type.html">secant_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1halley__type.html">halley_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1newton__type.html">newton_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1ridders__type.html">ridders_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1toms748__type.html">toms748_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1schroder__type.html">schroder_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1bisection__type.html">bisection_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1iteration__type.html">iteration_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1bracket__type.html">bracket_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1hybrid__type.html">hybrid_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1method__type.html">method_type</a><br  />
</dd></dl>
<p><br  />
<a class="anchor" id="finmain-schroder"></a><b>Final Remarks</b> <a href="#finmain-schroder">⛓</a> </p><hr  />
<p> If you believe this algorithm or its documentation can be improved, <b>we appreciate your contribution and help</b> <a href="https://github.com/cdslaborg/paramonte/tree/master/src/fortran/main/pm_mathRoot.F90#L1215 " target="_blank"><b>to edit this page's documentation and source file on GitHub</b></a>.<br  />
 For details on the naming abbreviations, see <a class="el" href="index.html#ParaMonteLangAbbreviationGuidlines">this page</a>.<br  />
 For details on the naming conventions, see <a class="el" href="index.html#ParaMonteLangNamingConventions">this page</a>.<br  />
 This software is distributed under the <a href="https://github.com/cdslaborg/paramonte#license" target="_blank">MIT license</a> <b>with additional terms outlined below.</b><br  />
</p><ol>
<li>
If you use any parts or concepts from this library to any extent, <b>you must acknowledge the usage by citing the relevant</b> <a href="https://www.cdslab.org/paramonte/generic/latest/overview/preface/#how-to-acknowledge-the-use-of-the-paramonte-library-in-your-work" target="_blank"><b>publications of the ParaMonte library</b></a>.<br  />
</li>
<li>
If you regenerate any parts/ideas from this library in a programming environment other than those currently supported by this ParaMonte library, <b>you must also ask the end users to</b> <a href="https://www.cdslab.org/paramonte/generic/latest/overview/preface/#how-to-acknowledge-the-use-of-the-paramonte-library-in-your-work" target="_blank"><b>cite this original ParaMonte library</b></a>.<br  />
</li>
</ol>
<dl class="section copyright"><dt>Copyright</dt><dd><a href="https://www.cdslab.org" target="_blank">Computational Data Science Lab</a></dd></dl>
<dl class="authors"><dt><b><a class="el" href="authors.html#_authors000831">Author:</a></b></dt><dd><a href="https://www.github.com/shahmoradi" target="_blank">Amir Shahmoradi</a>, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin </dd></dl>

<p class="definition">Definition at line <a class="el" href="pm__mathRoot_8F90_source.html#l01219">1219</a> of file <a class="el" href="pm__mathRoot_8F90_source.html">pm_mathRoot.F90</a>.</p>

</div>
</div>
<a id="aeada6d7662ab9da56ae68e165f35be3b" name="aeada6d7662ab9da56ae68e165f35be3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeada6d7662ab9da56ae68e165f35be3b">&#9670;&nbsp;</a></span>secant</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structpm__mathRoot_1_1secant__type.html">secant_type</a>), parameter pm_mathRoot::secant = <a class="el" href="structpm__mathRoot_1_1secant__type.html">secant_type</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a scalar <code>parameter</code> object of type <a class="el" href="structpm__mathRoot_1_1secant__type.html">secant_type</a> that is exclusively used to signify the use of Secant method of root-finding within an interface of a procedure of the ParaMonte library.<br  />
 </p>
<p >See the root-finding section in the documentation of <a class="el" href="namespacepm__mathRoot.html">pm_mathRoot</a> for more details about this root-finding method.<br  />
 For example usage, see the documentation of the target procedure requiring this object.<br  />
</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacepm__mathRoot.html#a3409e5000efdde261d2f3265678d0436">brent</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a7e707e2dada15fddfbd434f621f6b1ef">false</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#aeada6d7662ab9da56ae68e165f35be3b">secant</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#add19d3b40dedb3c60958cb830fdcd2cc">halley</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a4ab1ab19049b29b25610aef4eaedfd3e">newton</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a3e803f26dcf937fbb6158b0dbbd94960">ridders</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a471263361906d447d3ec06b1bf3eef0b">toms748</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#aea044c5c7944004b6c2f9c050e3cf810">schroder</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a5504dde0cb89575fd6f0882739a0d7b7">bisection</a><br  />
 <a class="el" href="structpm__mathRoot_1_1brent__type.html">brent_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1false__type.html">false_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1secant__type.html">secant_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1halley__type.html">halley_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1newton__type.html">newton_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1ridders__type.html">ridders_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1toms748__type.html">toms748_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1schroder__type.html">schroder_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1bisection__type.html">bisection_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1iteration__type.html">iteration_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1bracket__type.html">bracket_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1hybrid__type.html">hybrid_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1method__type.html">method_type</a><br  />
</dd></dl>
<p><br  />
<a class="anchor" id="finmain-secant"></a><b>Final Remarks</b> <a href="#finmain-secant">⛓</a> </p><hr  />
<p> If you believe this algorithm or its documentation can be improved, <b>we appreciate your contribution and help</b> <a href="https://github.com/cdslaborg/paramonte/tree/master/src/fortran/main/pm_mathRoot.F90#L960 " target="_blank"><b>to edit this page's documentation and source file on GitHub</b></a>.<br  />
 For details on the naming abbreviations, see <a class="el" href="index.html#ParaMonteLangAbbreviationGuidlines">this page</a>.<br  />
 For details on the naming conventions, see <a class="el" href="index.html#ParaMonteLangNamingConventions">this page</a>.<br  />
 This software is distributed under the <a href="https://github.com/cdslaborg/paramonte#license" target="_blank">MIT license</a> <b>with additional terms outlined below.</b><br  />
</p><ol>
<li>
If you use any parts or concepts from this library to any extent, <b>you must acknowledge the usage by citing the relevant</b> <a href="https://www.cdslab.org/paramonte/generic/latest/overview/preface/#how-to-acknowledge-the-use-of-the-paramonte-library-in-your-work" target="_blank"><b>publications of the ParaMonte library</b></a>.<br  />
</li>
<li>
If you regenerate any parts/ideas from this library in a programming environment other than those currently supported by this ParaMonte library, <b>you must also ask the end users to</b> <a href="https://www.cdslab.org/paramonte/generic/latest/overview/preface/#how-to-acknowledge-the-use-of-the-paramonte-library-in-your-work" target="_blank"><b>cite this original ParaMonte library</b></a>.<br  />
</li>
</ol>
<dl class="section copyright"><dt>Copyright</dt><dd><a href="https://www.cdslab.org" target="_blank">Computational Data Science Lab</a></dd></dl>
<dl class="authors"><dt><b><a class="el" href="authors.html#_authors000825">Author:</a></b></dt><dd><a href="https://www.github.com/shahmoradi" target="_blank">Amir Shahmoradi</a>, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin </dd></dl>

<p class="definition">Definition at line <a class="el" href="pm__mathRoot_8F90_source.html#l00964">964</a> of file <a class="el" href="pm__mathRoot_8F90_source.html">pm_mathRoot.F90</a>.</p>

</div>
</div>
<a id="a471263361906d447d3ec06b1bf3eef0b" name="a471263361906d447d3ec06b1bf3eef0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a471263361906d447d3ec06b1bf3eef0b">&#9670;&nbsp;</a></span>toms748</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structpm__mathRoot_1_1toms748__type.html">toms748_type</a>), parameter pm_mathRoot::toms748 = <a class="el" href="structpm__mathRoot_1_1toms748__type.html">toms748_type</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a scalar <code>parameter</code> object of type <a class="el" href="structpm__mathRoot_1_1toms748__type.html">toms748_type</a> that is exclusively used to signify the use of TOMS748 method of root-finding within an interface of a procedure of the ParaMonte library.<br  />
 </p>
<p >See the root-finding section in the documentation of <a class="el" href="namespacepm__mathRoot.html">pm_mathRoot</a> for more details about this root-finding method.<br  />
 For example usage, see the documentation of the target procedure requiring this object.<br  />
</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacepm__mathRoot.html#a3409e5000efdde261d2f3265678d0436">brent</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a7e707e2dada15fddfbd434f621f6b1ef">false</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#aeada6d7662ab9da56ae68e165f35be3b">secant</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#add19d3b40dedb3c60958cb830fdcd2cc">halley</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a4ab1ab19049b29b25610aef4eaedfd3e">newton</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a3e803f26dcf937fbb6158b0dbbd94960">ridders</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a471263361906d447d3ec06b1bf3eef0b">toms748</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#aea044c5c7944004b6c2f9c050e3cf810">schroder</a><br  />
 <a class="el" href="namespacepm__mathRoot.html#a5504dde0cb89575fd6f0882739a0d7b7">bisection</a><br  />
 <a class="el" href="structpm__mathRoot_1_1brent__type.html">brent_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1false__type.html">false_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1secant__type.html">secant_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1halley__type.html">halley_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1newton__type.html">newton_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1ridders__type.html">ridders_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1toms748__type.html">toms748_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1schroder__type.html">schroder_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1bisection__type.html">bisection_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1iteration__type.html">iteration_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1bracket__type.html">bracket_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1hybrid__type.html">hybrid_type</a><br  />
 <a class="el" href="structpm__mathRoot_1_1method__type.html">method_type</a><br  />
</dd></dl>
<p><br  />
<a class="anchor" id="finmain-toms748"></a><b>Final Remarks</b> <a href="#finmain-toms748">⛓</a> </p><hr  />
<p> If you believe this algorithm or its documentation can be improved, <b>we appreciate your contribution and help</b> <a href="https://github.com/cdslaborg/paramonte/tree/master/src/fortran/main/pm_mathRoot.F90#L790 " target="_blank"><b>to edit this page's documentation and source file on GitHub</b></a>.<br  />
 For details on the naming abbreviations, see <a class="el" href="index.html#ParaMonteLangAbbreviationGuidlines">this page</a>.<br  />
 For details on the naming conventions, see <a class="el" href="index.html#ParaMonteLangNamingConventions">this page</a>.<br  />
 This software is distributed under the <a href="https://github.com/cdslaborg/paramonte#license" target="_blank">MIT license</a> <b>with additional terms outlined below.</b><br  />
</p><ol>
<li>
If you use any parts or concepts from this library to any extent, <b>you must acknowledge the usage by citing the relevant</b> <a href="https://www.cdslab.org/paramonte/generic/latest/overview/preface/#how-to-acknowledge-the-use-of-the-paramonte-library-in-your-work" target="_blank"><b>publications of the ParaMonte library</b></a>.<br  />
</li>
<li>
If you regenerate any parts/ideas from this library in a programming environment other than those currently supported by this ParaMonte library, <b>you must also ask the end users to</b> <a href="https://www.cdslab.org/paramonte/generic/latest/overview/preface/#how-to-acknowledge-the-use-of-the-paramonte-library-in-your-work" target="_blank"><b>cite this original ParaMonte library</b></a>.<br  />
</li>
</ol>
<dl class="section copyright"><dt>Copyright</dt><dd><a href="https://www.cdslab.org" target="_blank">Computational Data Science Lab</a></dd></dl>
<dl class="authors"><dt><b><a class="el" href="authors.html#_authors000821">Author:</a></b></dt><dd><a href="https://www.github.com/shahmoradi" target="_blank">Amir Shahmoradi</a>, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin </dd></dl>

<p class="definition">Definition at line <a class="el" href="pm__mathRoot_8F90_source.html#l00794">794</a> of file <a class="el" href="pm__mathRoot_8F90_source.html">pm_mathRoot.F90</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
    <!-- start footer part -->
    <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
      <ul>
        <li class="navelem"><a class="el" href="namespacepm__mathRoot.html">pm_mathRoot</a></li>
        <li class="footer">Generated on Mon Apr 1 2024 23:20:36 for ParaMonte Fortran 2.0.0 by <a href="http://www.doxygen.org/index.html" target="_blank"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
      </ul>
    </div>
    <div style="color: #ffffff; float: none; width: 100%;">
        <span style="font-size:0.8em">
            <script type="text/javascript">
                var sc_project=12178963; 
                var sc_invisible=1; 
                var sc_security="e0dfe0f9"; 
                var sc_text=3; 
                var scJsHost = "https://";
                document.write("<sc"+"ript type='text/javascript' src='" +
                scJsHost+
                "statcounter.com/counter/counter.js'></"+"script>");
            </script>
        </span>
    </div>
</body>
</html>
